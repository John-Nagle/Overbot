<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html><head>
<link rel="STYLESHEET" href="opencvref.css" charset="ISO-8859-1" type="text/css">
<title>OpenCV: Basic Structures and Operations Reference</title>
</head><body>

<h1>Basic Structures and Operations Reference</h1>

<hr><p><ul>
<li><a href="#ch1_helper_structs">Helper structures</a>
<ul>
<li><a href="#decl_CvPoint">Point</a>
<li><a href="#decl_CvPoint2D32f">Point2D32f</a>
<li><a href="#decl_CvPoint3D32f">Point3D32f</a>
<li><a href="#decl_CvSize">Size</a>
<li><a href="#decl_CvSize2D32f">Size2D32f</a>
<li><a href="#decl_CvRect">Rect</a>
<li><a href="#decl_CvScalar">Scalar</a>
</ul>
<li><a href="#ch1_array_structs">Array structures</a>
<ul>
<li><a href="#decl_CvMat">Mat</a>
<li><a href="#decl_CvMatND">MatND</a>
<li><a href="#decl_CvSparseMat">SparseMat</a>
<li><a href="#decl_CvArr">Arr</a>
</ul>
<li><a href="#ch1_array_utils">Arrays: Allocation/deallocation/copying/setting and retrieving parts</a>
<ul>
<li><a href="#decl_cvAlloc">Alloc</a>
<li><a href="#decl_cvFree">Free</a>
<li><a href="#decl_cvCreateImage">CreateImage</a>
<li><a href="#decl_cvCreateImageHeader">CreateImageHeader</a>
<li><a href="#decl_cvReleaseImageHeader">ReleaseImageHeader</a>
<li><a href="#decl_cvReleaseImage">ReleaseImage</a>
<li><a href="#decl_cvInitImageHeader">InitImageHeader</a>
<li><a href="#decl_cvCloneImage">CloneImage</a>
<li><a href="#decl_cvSetImageCOI">SetImageCOI</a>
<li><a href="#decl_cvGetImageCOI">GetImageCOI</a>
<li><a href="#decl_cvSetImageROI">SetImageROI</a>
<li><a href="#decl_cvResetImageROI">ResetImageROI</a>
<li><a href="#decl_cvGetImageROI">GetImageROI</a>
<li><a href="#decl_cvCreateMat">CreateMat</a>
<li><a href="#decl_cvCreateMatHeader">CreateMatHeader</a>
<li><a href="#decl_cvReleaseMat">ReleaseMat</a>
<li><a href="#decl_cvInitMatHeader">InitMatHeader</a>
<li><a href="#decl_cvMat">Mat</a>
<li><a href="#decl_cvCloneMat">CloneMat</a>
<li><a href="#decl_cvCreateMatND">CreateMatND</a>
<li><a href="#decl_cvCreateMatNDHeader">CreateMatNDHeader</a>
<li><a href="#decl_cvReleaseMatND">ReleaseMatND</a>
<li><a href="#decl_cvInitMatNDHeader">InitMatNDHeader</a>
<li><a href="#decl_cvCloneMatND">CloneMatND</a>
<li><a href="#decl_cvDecRefData">DecRefData</a>
<li><a href="#decl_cvIncRefData">IncRefData</a>
<li><a href="#decl_cvCreateData">CreateData</a>
<li><a href="#decl_cvReleaseData">ReleaseData</a>
<li><a href="#decl_cvSetData">SetData</a>
<li><a href="#decl_cvGetRawData">GetRawData</a>
<li><a href="#decl_cvGetMat">GetMat</a>
<li><a href="#decl_cvGetImage">GetImage</a>
<li><a href="#decl_cvGetSubRect">GetSubRect</a>
<li><a href="#decl_cvGetRow">GetRow</a>
<li><a href="#decl_cvGetCol">GetCol</a>
<li><a href="#decl_cvGetDiag">GetDiag</a>
<li><a href="#decl_cvGetSize">GetSize</a>
<li><a href="#decl_cvCreateSparseMat">CreateSparseMat</a>
<li><a href="#decl_cvReleaseSparseMat">ReleaseSparseMat</a>
<li><a href="#decl_cvCloneSparseMat">CloneSparseMat</a>
<li><a href="#decl_cvInitSparseMatIterator">InitSparseMatIterator</a>
<li><a href="#decl_cvGetNextSparseNode">GetNextSparseNode</a>
<li><a href="#decl_cvGetElemType">GetElemType</a>
<li><a href="#decl_cvGetDims">GetDims</a>
<li><a href="#decl_cvPtr*D">Ptr*D</a>
<li><a href="#decl_cvGet*D">Get*D</a>
<li><a href="#decl_cvGetReal*D">GetReal*D</a>
<li><a href="#decl_cvmGet">mGet</a>
<li><a href="#decl_cvSet*D">Set*D</a>
<li><a href="#decl_cvSetReal*D">SetReal*D</a>
<li><a href="#decl_cvmSet">mSet</a>
<li><a href="#decl_cvClear*D">Clear*D</a>
<li><a href="#decl_cvCopy">Copy</a>
<li><a href="#decl_cvSet">Set</a>
<li><a href="#decl_cvSetZero">SetZero</a>
</ul>
<li><a href="#ch1_array_basic">Arrays: Conversions, transformations, basic operations </a>
<ul>
<li><a href="#decl_cvReshape">Reshape</a>
<li><a href="#decl_cvReshapeMatND">ReshapeMatND</a>
<li><a href="#decl_cvRepeat">Repeat</a>
<li><a href="#decl_cvFlip">Flip</a>
<li><a href="#decl_cvCvtPixToPlane">CvtPixToPlane</a>
<li><a href="#decl_cvCvtPlaneToPix">CvtPlaneToPix</a>
<li><a href="#decl_cvConvertScale">ConvertScale</a>
<li><a href="#decl_cvConvertScaleAbs">ConvertScaleAbs</a>
<li><a href="#decl_cvAdd">Add</a>
<li><a href="#decl_cvAddS">AddS</a>
<li><a href="#decl_cvSub">Sub</a>
<li><a href="#decl_cvSubS">SubS</a>
<li><a href="#decl_cvSubRS">SubRS</a>
<li><a href="#decl_cvMul">Mul</a>
<li><a href="#decl_cvDiv">Div</a>
<li><a href="#decl_cvAnd">And</a>
<li><a href="#decl_cvAndS">AndS</a>
<li><a href="#decl_cvOr">Or</a>
<li><a href="#decl_cvOrS">OrS</a>
<li><a href="#decl_cvXor">Xor</a>
<li><a href="#decl_cvXorS">XorS</a>
<li><a href="#decl_cvNot">Not</a>
<li><a href="#decl_cvCmp">Cmp</a>
<li><a href="#decl_cvCmpS">CmpS</a>
<li><a href="#decl_cvInRange">InRange</a>
<li><a href="#decl_cvInRangeS">InRangeS</a>
<li><a href="#decl_cvMax">Max</a>
<li><a href="#decl_cvMaxS">MaxS</a>
<li><a href="#decl_cvMin">Min</a>
<li><a href="#decl_cvMinS">MinS</a>
<li><a href="#decl_cvAbsDiff">AbsDiff</a>
<li><a href="#decl_cvAbsDiffS">AbsDiffS</a>
</ul>
<li><a href="#ch1_array_stat">Array statistics</a>
<ul>
<li><a href="#decl_cvCountNonZero">CountNonZero</a>
<li><a href="#decl_cvSum">Sum</a>
<li><a href="#decl_cvAvg">Avg</a>
<li><a href="#decl_cvAvgSdv">AvgSdv</a>
<li><a href="#decl_cvMinMaxLoc">MinMaxLoc</a>
<li><a href="#decl_cvNorm">Norm</a>
</ul>
<li><a href="#ch1_matrix_op">Matrix Operations, Linear Algebra and Math Functions</a>
<ul>
<li><a href="#decl_cvSetIdentity">SetIdentity</a>
<li><a href="#decl_cvDotProduct">DotProduct</a>
<li><a href="#decl_cvCrossProduct">CrossProduct</a>
<li><a href="#decl_cvScaleAdd">ScaleAdd</a>
<li><a href="#decl_cvMatMulAdd">MatMulAdd</a>
<li><a href="#decl_cvGEMM">GEMM</a>
<li><a href="#decl_cvMatMulAddS">MatMulAddS</a>
<li><a href="#decl_cvMulTransposed">MulTransposed</a>
<li><a href="#decl_cvTrace">Trace</a>
<li><a href="#decl_cvTranspose">Transpose</a>
<li><a href="#decl_cvDet">Det</a>
<li><a href="#decl_cvInvert">Invert</a>
<li><a href="#decl_cvSolve">Solve</a>
<li><a href="#decl_cvSVD">SVD</a>
<li><a href="#decl_cvSVBkSb">SVBkSb</a>
<li><a href="#decl_cvEigenVV">EigenVV</a>
<li><a href="#decl_cvPerspectiveTransform">PerspectiveTransform</a>
<li><a href="#decl_cvCalcCovarMatrix">CalcCovarMatrix</a>
<li><a href="#decl_cvMahalonobis">Mahalonobis</a>
<li><a href="#decl_cvCartToPolar">CartToPolar</a>
<li><a href="#decl_cvPolarToCart">PolarToCart</a>
<li><a href="#decl_cvPow">Pow</a>
<li><a href="#decl_cvExp">Exp</a>
<li><a href="#decl_cvLog">Log</a>
<li><a href="#decl_cvCheckArr">CheckArr</a>
<li><a href="#decl_cvRandInit">RandInit</a>
<li><a href="#decl_cvRandSetRange">RandSetRange</a>
<li><a href="#decl_cvRand">Rand</a>
<li><a href="#decl_cvRandNext">RandNext</a>
<li><a href="#decl_cvDFT">DFT</a>
<li><a href="#decl_cvMulCss">MulCss</a>
<li><a href="#decl_cvDCT">DCT</a>
</ul>
<li><a href="#ch1_dynamic_structs">Dynamic Data Structures</a>
<ul>
<li><a href="#decl_CvMemStorage">MemStorage</a>
<li><a href="#decl_CvMemBlock">MemBlock</a>
<li><a href="#decl_CvMemStoragePos">MemStoragePos</a>
<li><a href="#decl_cvCreateMemStorage">CreateMemStorage</a>
<li><a href="#decl_cvCreateChildMemStorage">CreateChildMemStorage</a>
<li><a href="#decl_cvReleaseMemStorage">ReleaseMemStorage</a>
<li><a href="#decl_cvClearMemStorage">ClearMemStorage</a>
<li><a href="#decl_cvMemStorageAlloc">MemStorageAlloc</a>
<li><a href="#decl_cvSaveMemStoragePos">SaveMemStoragePos</a>
<li><a href="#decl_cvRestoreMemStoragePos">RestoreMemStoragePos</a>
</ul>
<li><a href="#ch1_seqs">Sequences</a>
<ul>
<li><a href="#decl_CvSeq">Seq</a>
<li><a href="#decl_CvSeqBlock">SeqBlock</a>
<li><a href="#decl_cvCreateSeq">CreateSeq</a>
<li><a href="#decl_cvSetSeqBlockSize">SetSeqBlockSize</a>
<li><a href="#decl_cvSeqPush">SeqPush</a>
<li><a href="#decl_cvSeqPop">SeqPop</a>
<li><a href="#decl_cvSeqPushFront">SeqPushFront</a>
<li><a href="#decl_cvSeqPopFront">SeqPopFront</a>
<li><a href="#decl_cvSeqPushMulti">SeqPushMulti</a>
<li><a href="#decl_cvSeqPopMulti">SeqPopMulti</a>
<li><a href="#decl_cvSeqInsert">SeqInsert</a>
<li><a href="#decl_cvSeqRemove">SeqRemove</a>
<li><a href="#decl_cvClearSeq">ClearSeq</a>
<li><a href="#decl_cvGetSeqElem">GetSeqElem</a>
<li><a href="#decl_cvSeqElemIdx">SeqElemIdx</a>
<li><a href="#decl_CvtSeqToArray">tSeqToArray</a>
<li><a href="#decl_cvMakeSeqHeaderForArray">MakeSeqHeaderForArray</a>
<li><a href="#decl_cvSeqSlice">SeqSlice</a>
<li><a href="#decl_cvSeqRemoveSlice">SeqRemoveSlice</a>
<li><a href="#decl_cvSeqInsertSlice">SeqInsertSlice</a>
<li><a href="#decl_cvSeqInvert">SeqInvert</a>
<li><a href="#decl_cvSeqSort">SeqSort</a>
<li><a href="#decl_cvStartAppendToSeq">StartAppendToSeq</a>
<li><a href="#decl_cvStartWriteSeq">StartWriteSeq</a>
<li><a href="#decl_cvEndWriteSeq">EndWriteSeq</a>
<li><a href="#decl_cvFlushSeqWriter">FlushSeqWriter</a>
<li><a href="#decl_cvStartReadSeq">StartReadSeq</a>
<li><a href="#decl_cvGetSeqReaderPos">GetSeqReaderPos</a>
<li><a href="#decl_cvSetSeqReaderPos">SetSeqReaderPos</a>
</ul>
<li><a href="#ch1_sets">Sets</a>
<ul>
<li><a href="#decl_CvSet">Set</a>
<li><a href="#decl_cvCreateSet">CreateSet</a>
<li><a href="#decl_cvSetAdd">SetAdd</a>
<li><a href="#decl_cvSetRemove">SetRemove</a>
<li><a href="#decl_cvSetNew">SetNew</a>
<li><a href="#decl_cvSetRemoveByPtr">SetRemoveByPtr</a>
<li><a href="#decl_cvGetSetElem">GetSetElem</a>
<li><a href="#decl_cvClearSet">ClearSet</a>
</ul>
<li><a href="#ch1_graphs">Graphs</a>
<ul>
<li><a href="#decl_CvGraph">Graph</a>
<li><a href="#decl_cvCreateGraph">CreateGraph</a>
<li><a href="#decl_cvGraphAddVtx">GraphAddVtx</a>
<li><a href="#decl_cvGraphRemoveVtx">GraphRemoveVtx</a>
<li><a href="#decl_cvGraphRemoveVtxByPtr">GraphRemoveVtxByPtr</a>
<li><a href="#decl_cvGetGraphVtx">GetGraphVtx</a>
<li><a href="#decl_cvGraphVtxIdx">GraphVtxIdx</a>
<li><a href="#decl_cvGraphAddEdge">GraphAddEdge</a>
<li><a href="#decl_cvGraphAddEdgeByPtr">GraphAddEdgeByPtr</a>
<li><a href="#decl_cvGraphRemoveEdge">GraphRemoveEdge</a>
<li><a href="#decl_cvGraphRemoveEdgeByPtr">GraphRemoveEdgeByPtr</a>
<li><a href="#decl_cvFindGraphEdge">FindGraphEdge</a>
<li><a href="#decl_cvFindGraphEdgeByPtr">FindGraphEdgeByPtr</a>
<li><a href="#decl_cvGraphEdgeIdx">GraphEdgeIdx</a>
<li><a href="#decl_cvGraphVtxDegree">GraphVtxDegree</a>
<li><a href="#decl_cvGraphVtxDegreeByPtr">GraphVtxDegreeByPtr</a>
<li><a href="#decl_cvClearGraph">ClearGraph</a>
<li><a href="#decl_cvCloneGraph">CloneGraph</a>
<li><a href="#decl_CvGraphScanner">GraphScanner</a>
<li><a href="#decl_cvStartScanGraph">StartScanGraph</a>
<li><a href="#decl_cvNextGraphItem">NextGraphItem</a>
<li><a href="#decl_cvEndScanGraph">EndScanGraph</a>
</ul>
<li><a href="#ch1_trees">Trees</a>
<ul>
<li><a href="#decl_CvTreeNodeIterator">TreeNodeIterator</a>
<li><a href="#decl_cvInitTreeNodeIterator">InitTreeNodeIterator</a>
<li><a href="#decl_cvNextTreeNode">NextTreeNode</a>
<li><a href="#decl_cvPrevTreeNode">PrevTreeNode</a>
<li><a href="#decl_cvTreeToNodeSeq">TreeToNodeSeq</a>
<li><a href="#decl_cvInsertNodeIntoTree">InsertNodeIntoTree</a>
<li><a href="#decl_cvRemoveNodeFromTree">RemoveNodeFromTree</a>
</ul>
<li><a href="#ch1_persistence">Persistence (Writing and Reading Structures)</a>
<ul>
<li><a href="#decl_cvOpenFileStorage">OpenFileStorage</a>
<li><a href="#decl_cvReleaseFileStorage">ReleaseFileStorage</a>
<li><a href="#decl_cvWrite">Write</a>
<li><a href="#decl_cvStartWriteStruct">StartWriteStruct</a>
<li><a href="#decl_cvEndWriteStruct">EndWriteStruct</a>
<li><a href="#decl_cvWriteElem">WriteElem</a>
<li><a href="#decl_cvRead">Read</a>
<li><a href="#decl_cvReadElem">ReadElem</a>
<li><a href="#decl_CvFileNode">FileNode</a>
<li><a href="#decl_cvGetFileNode">GetFileNode</a>
<li><a href="#decl_cvReadFileNode">ReadFileNode</a>
</ul></ul></p>


<!-- *****************************************************************************************
     *****************************************************************************************
     ***************************************************************************************** -->

<hr><h2><a name="ch1_helper_structs">Helper structures</a></h2>

<hr><h3><a name="decl_CvPoint">CvPoint</a></h3>
<p class="Blurb">2D point with integer coordinates</p>
<pre>
    typedef struct CvPoint
    {
        int x; /* x-coordinate, usually zero-based */
        int y; /* y-coordinate, usually zero-based */
    }
    CvPoint;

    /* the constructor function */
    inline CvPoint cvPoint( int x, int y );

    /* conversion from CvPoint2D32f */
    inline CvPoint cvPointFrom32f( CvPoint2D32f point );
</pre>

<hr><h3><a name="decl_CvPoint2D32f">CvPoint2D32f</a></h3>
<p class="Blurb">2D point with floating-point coordinates</p>
<pre>
    typedef struct CvPoint2D32f
    {
        float x; /* x-coordinate, usually zero-based */
        float y; /* y-coordinate, usually zero-based */
    }
    CvPoint2D32f;

    /* the constructor function */
    inline CvPoint2D32f cvPoint2D32f( double x, double y );

    /* conversion from CvPoint */
    inline CvPoint2D32f cvPointTo32f( CvPoint point );
</pre>


<hr><h3><a name="decl_CvPoint3D32f">CvPoint3D32f</a></h3>
<p class="Blurb">3D point with floating-point coordinates</p>
<pre>
    typedef struct CvPoint3D32f
    {
        float x; /* x-coordinate, usually zero-based */
        float y; /* y-coordinate, usually zero-based */
        float z; /* z-coordinate, usually zero-based */
    }
    CvPoint3D32f;

    /* the constructor function */
    inline CvPoint3D32f cvPoint3D32f( double x, double y, double z );
</pre>


<hr><h3><a name="decl_CvSize">CvSize</a></h3>
<p class="Blurb">pixel-accurate size of a rectangle</p>
<pre>
    typedef struct CvSize
    {
        int width; /* width of the rectangle */
        int height; /* height of the rectangle */
    }
    CvSize;

    /* the constructor function */
    inline CvSize cvSize( int width, int height );
</pre>


<hr><h3><a name="decl_CvSize2D32f">CvSize2D32f</a></h3>
<p class="Blurb">sub-pixel accurate size of a rectangle</p>
<pre>
    typedef struct CvSize2D32f
    {
        float width; /* width of the box */
        float height; /* height of the box */
    }
    CvSize2D32f;

    /* the constructor function */
    inline CvSize2D cvSize32f( double width, double height );
</pre>


<hr><h3><a name="decl_CvRect">CvRect</a></h3>
<p class="Blurb">offset and size of a rectangle</p>
<pre>
    typedef struct CvRect
    {
        int x; /* x-coordinate of the left-most rectangle corner[s] */
        int y; /* y-coordinate of the top-most or bottom-most
                  rectangle corner[s] */
        int width; /* width of the rectangle */
        int height; /* height of the rectangle */
    }
    CvRect;

    /* the constructor function */
    inline CvRect cvRect( int x, int y, int width, int height );
</pre>


<hr><h3><a name="decl_CvScalar">CvScalar</a></h3>
<p class="Blurb">A container for 1-,2-,3- or 4-tuples of numbers</p>
<pre>
    typedef struct CvScalar
    {
        double val[4];
    }
    CvScalar;

    /* the constructor function: initializes val[0] with val0, val[1] with val1 etc. */
    inline CvScalar cvScalar( double val0, double val1=0,
                              double val2=0, double val3=0 );
    /* the constructor function: initializes val[0]...val[3] with val0123 */
    inline CvScalar cvScalarAll( double val0123 );

    /* the constructor function: initializes val[0] with val0, val[1]...val[3] with zeros */
    inline CvScalar cvRealScalar( double val0 );
</pre>


<!-- *****************************************************************************************
     *****************************************************************************************
     ***************************************************************************************** -->

<hr><h2><a name="ch1_array_structs">Array structures</a></h2>

<hr><h3><a name="decl_CvMat">CvMat</a></h3>
<p class="Blurb">Multi-channel matrix</p>
<pre>
    typedef struct CvMat
    {
        int type; /* CvMat signature (CV_MAT_MAGIC_VAL), element type and flags */
        int step; /* full row length in bytes */

        int* refcount; /* underlying data reference counter */

        union
        {
            uchar* ptr;
            short* s;
            int* i;
            float* fl;
            double* db;
        } data; /* data pointers */

    #ifdef __cplusplus
        union
        {
            int rows;
            int height;
        };

        union
        {
            int cols;
            int width;
        };
    #else
        int rows; /* number of rows */
        int cols; /* number of columns */
    #endif

    } CvMat;
</pre>


<hr><h3><a name="decl_CvMatND">CvMatND</a></h3>
<p class="Blurb">Multi-dimensional dense multi-channel array</p>
<pre>
    typedef struct CvMatND
    {
        int type; /* CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags */
        int dims; /* number of array dimensions */

        int* refcount; /* underlying data reference counter */

        union
        {
            uchar* ptr;
            short* s;
            int* i;
            float* fl;
            double* db;
        } data; /* data pointers */

        /* pairs (number of elements, distance between elements in bytes) for
           every dimension */
        struct
        {
            int size;
            int step;
        }
        dim[CV_MAX_DIM];

    } CvMatND;
</pre>


<hr><h3><a name="decl_CvSparseMat">CvSparseMat</a></h3>
<p class="Blurb">Multi-dimensional sparse multi-channel array</p>
<pre>
    typedef struct CvSparseMat
    {
        int type; /* CvSparseMat signature (CV_SPARSE_MAT_MAGIC_VAL), element type and flags */
        int dims; /* number of dimensions */
        int* refcount; /* reference counter - not used */
        struct CvSet* heap; /* a pool of hashtable nodes */
        void** hashtable; /* hashtable: each entry has a list of nodes
                             having the same "hashvalue modulo hashsize" */
        int hashsize; /* size of hashtable */
        int total; /* total number of sparse array nodes */
        int valoffset; /* value offset in bytes for the array nodes */
        int idxoffset; /* index offset in bytes for the array nodes */
        int size[CV_MAX_DIM]; /* array of dimension sizes */

    } CvSparseMat;
</pre>


<hr><h3><a name="decl_IplImage">IplImage</a></h3>
<p class="Blurb">IPL image header</p>
<pre>
    typedef struct _IplImage
    {
        int  nSize;         /* sizeof(IplImage) */
        int  ID;            /* version (=0)*/
        int  nChannels;     /* Most of OpenCV functions support 1,2,3 or 4 channels */
        int  alphaChannel;  /* ignored by OpenCV */
        int  depth;         /* pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16S,
                               IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported */
        char colorModel[4]; /* ignored by OpenCV */
        char channelSeq[4]; /* ditto */
        int  dataOrder;     /* 0 - interleaved color channels, 1 - separate color channels.
                               cvCreateImage can only create interleaved images */
        int  origin;        /* 0 - top-left origin,
                               1 - bottom-left origin (Windows bitmaps style) */
        int  align;         /* Alignment of image rows (4 or 8).
                               OpenCV ignores it and uses widthStep instead */
        int  width;         /* image width in pixels */
        int  height;        /* image height in pixels */
        struct _IplROI *roi;/* image ROI. when it is not NULL, this specifies image region to process */
        struct _IplImage *maskROI; /* must be NULL in OpenCV */
        void  *imageId;     /* ditto */
        struct _IplTileInfo *tileInfo; /* ditto */
        int  imageSize;     /* image data size in bytes
                               (=image->height*image->widthStep
                               in case of interleaved data)*/
        char *imageData;  /* pointer to aligned image data */
        int  widthStep;   /* size of aligned image row in bytes */
        int  BorderMode[4]; /* border completion mode, ignored by OpenCV */
        int  BorderConst[4]; /* ditto */
        char *imageDataOrigin; /* pointer to a very origin of image data
                                  (not necessarily aligned) -
                                  it is needed for correct image deallocation */
    }
    IplImage;
</pre>
<p>
The structure <em>IplImage</em> came from <em>Intel Image Processing Library</em> where
the format is native. OpenCV supports only subset of the possible IplImage formats:
<ul>
<li><code>alphaChannel</code> is ignored by OpenCV.
<li><code>colorModel</code> and <code>channelSeq</code> are ignored by OpenCV. The single OpenCV function
<a href="#decl_cvCvtColor">cvCvtColor</a> working with color spaces takes the source and destination color spaces
as a parameter.
<li><code>dataOrder</code> must be IPL_DATA_ORDER_PIXEL (the color channels are interleaved), however
selected channels of planar images can be processed as well if COI is set.
<li><code>align</code> is ignored by OpenCV, while <code>widthStep</code> is used to access to subsequent image rows.
<li><code>maskROI</code> is not supported. The function that can work with mask take it as a
separate parameter. Also the mask in OpenCV is 8-bit, whereas in IPL it is 1-bit.
<li><code>tileInfo</code> is not supported.
<li><code>BorderMode</code> and <code>BorderConst</code> are not supported. Every OpenCV function
working with a pixel neigborhood uses a single hard-coded border mode (most often, replication).
</ul>
Besides the above restrictions, OpenCV handles ROI differently. It requires that the sizes or ROI sizes of
all source and destination images match exactly (according to the operation, e.g. for <a href="#decl_cvPyrDown">cvPyrDown</a>
destination width(height) must be equal to source width(height) divided by 2 &plusmn;1),
whereas IPL processes the intersection area - that is, the sizes or ROI sizes of all images may
vary independently.
</p>


<hr><h3><a name="decl_CvArr">CvArr</a></h3>
<p class="Blurb">Arbitrary array</p>
<pre>
    typedef void CvArr;
</pre>
<p>
<a href="#decl_CvArr*">CvArr*</a> is used <em>only</em> as a function parameter to
specify that the function accepts arrays of more than a
single type, for example IplImage* and CvMat*. The particular array
type is determined in runtime from looking at the first 4-byte field of
array header.
</p>

<!-- *****************************************************************************************
     *****************************************************************************************
     ***************************************************************************************** -->

<hr><h2><a name="ch1_array_utils">Arrays: Allocation, deallocation, copying; setting and retrieving parts</a></h2>


<hr><h3><a name="decl_cvAlloc">Alloc</a></h3>
<p class="Blurb">Allocates memory buffer</p>
<pre>
void* cvAlloc( size_t size );
</pre><p><dl>
<dt>size<dd>Buffer size in bytes.
</dl><p>
The function <a href="#decl_cvAlloc">cvAlloc</a> allocates <em>size</em> bytes and
returns pointer to the allocated buffer. In case of error
the function reports an error and returns NULL pointer.
By default cvAlloc calls icvAlloc which itself calls malloc,
however it is possible to assign user-defined memory allocation/deallocation
functions using <a href="#decl_cvSetMemoryManager">cvSetMemoryManager</a> function.
</p>


<hr><h3><a name="decl_cvFree">Free</a></h3>
<p class="Blurb">Deallocates memory buffer</p>
<pre>
void cvFree( void** buffer );
</pre><p><dl>
<dt>buffer<dd>Double pointer to released buffer.
</dl><p>
The function <a href="#decl_cvFree">cvFree</a> deallocates memory buffer allocated by <a href="#decl_cvAlloc">cvAlloc</a>.
It clears the pointer to buffer upon exit, that is why the double pointer is
used. If *buffer is already NULL, the function does nothing
</p>


<hr><h3><a name="decl_cvCreateImage">CreateImage</a></h3>
<p class="Blurb">Creates header and allocates data</p>
<pre>
IplImage* cvCreateImage( CvSize size, int depth, int channels );
</pre><p><dl>
<dt>size<dd>Image width and height.
<dt>depth<dd>Bit depth of image elements. Can be one of:<br>
             IPL_DEPTH_8U - unsigned 8-bit integers<br>
             IPL_DEPTH_8S - signed 8-bit integers<br>
             IPL_DEPTH_16S - signed 16-bit integers<br>
             IPL_DEPTH_32S - signed 32-bit integers<br>
             IPL_DEPTH_32F - single precision floating-point numbers<br>
             IPL_DEPTH_64F - double precision floating-point numbers<br>
<dt>channels<dd>Number of channels per element(pixel). Can be 1, 2, 3 or 4.
             The channels are interleaved, for example the
             usual data layout of a color image is:<br>
             b0 g0 r0 b1 g1 r1 ...<br>
             Although in general IPL image format can store
             non-interleaved images as well and some of OpenCV
             can process it, this function can create interleaved images
             only.
</dl><p>
The function <a href="#decl_cvCreateImage">cvCreateImage</a> creates the header and allocates data. This call is a
shortened form of
<pre>
    header = cvCreateImageHeader(size,depth,channels);
    cvCreateData(header);
</pre>
</p>


<hr><h3><a name="decl_cvCreateImageHeader">CreateImageHeader</a></h3>
<p class="Blurb">Allocates, initializes, and returns structure IplImage</p>
<pre>
IplImage* cvCreateImageHeader( CvSize size, int depth, int channels );
</pre><p><dl>
<dt>size<dd>Image width and height.
<dt>depth<dd>Image depth (see CreateImage).
<dt>channels<dd>Number of channels (see CreateImage).
</dl><p>
The function <a href="#decl_cvCreateImageHeader">cvCreateImageHeader</a> allocates, initializes, and returns the structure
<em>IplImage</em>. This call is an analogue of
<pre>
  iplCreateImageHeader( channels, 0, depth,
                        channels == 1 ? "GRAY" : "RGB",
                        channels == 1 ? "GRAY" : channels == 3 ? "BGR" :
                        channels == 4 ? "BGRA" : "",
                        IPL_DATA_ORDER_PIXEL, IPL_ORIGIN_TL, 4,
                        size.width, size.height,
                        0,0,0,0);
</pre>
though it does not use IPL functions by default
(see also <em>CV_TURN_ON_IPL_COMPATIBILITY</em> macro)
</p>


<hr><h3><a name="decl_cvReleaseImageHeader">ReleaseImageHeader</a></h3>
<p class="Blurb">Releases header</p>
<pre>
void cvReleaseImageHeader( IplImage** image );
</pre><p><dl>
<dt>image<dd>Double pointer to the deallocated header.
</dl><p>
The function <a href="#decl_cvReleaseImageHeader">cvReleaseImageHeader</a> releases the header.
This call is an analogue of
<pre>
    if( image )
    {
        iplDeallocate( *image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI );
        *image = 0;
    }
</pre>
though it does not use IPL functions by default
(see also <em>CV_TURN_ON_IPL_COMPATIBILITY</em>)
</p>


<hr><h3><a name="decl_cvReleaseImage">ReleaseImage</a></h3>
<p class="Blurb">Releases header and image data</p>
<pre>
void cvReleaseImage( IplImage** image );
</pre><p><dl>
<dt>image<dd>Double pointer to the header of the deallocated image.
</dl></p><p>
The function <a href="#decl_cvReleaseImage">cvReleaseImage</a> releases the header and the image data. This call is a
shortened form of
<pre>
    if( *image )
    {
        cvReleaseData( *image );
        cvReleaseImageHeader( image );
    }
</pre>
</p>


<hr><h3><a name="decl_cvInitImageHeader">InitImageHeader</a></h3>
<p class="Blurb">Initializes allocated by user image header</p>
<pre>
void cvInitImageHeader( IplImage* image, CvSize size, int depth,
                        int channels, int origin, int align );
</pre><p><dl>
<dt>image<dd>Image header to initialize.
<dt>size<dd>Image width and height.
<dt>depth<dd>Image depth (see CreateImage).
<dt>channels<dd>Number of channels (see CreateImage).
<dt>origin<dd><em>IPL_ORIGIN_TL</em> or <em>IPL_ORIGIN_BL</em>.
<dt>align<dd>Alignment for image rows, typically 4 or 8 bytes.
</dl></p><p>
The function <a href="#decl_cvInitImageHeader">cvInitImageHeader</a> initializes the image header structure without
memory allocation.
</p>


<hr><h3><a name="decl_cvCloneImage">CloneImage</a></h3>
<p class="Blurb">Makes a full copy of image</p>
<pre>
IplImage* cvCloneImage( const IplImage* image );
</pre><p><dl>
<dt>image<dd>Original image.
</dl></p><p>
The function <a href="#decl_cvCloneImage">cvCloneImage</a> makes a full copy of the image including
header, ROI and data
</p>


<hr><h3><a name="decl_cvSetImageCOI">SetImageCOI</a></h3>
<p class="Blurb">Sets channel of interest to given value</p>
<pre>
void cvSetImageCOI( IplImage* image, int coi );
</pre><p><dl>
<dt>image<dd>Image header.
<dt>coi<dd>Channel of interest.
</dl><p>
The function <a href="#decl_cvSetImageCOI">cvSetImageCOI</a> sets the channel of interest
to a given value. Value 0 means that all channels are selected,
1 means that the first channel is selected etc.
If ROI is <em>NULL</em> and <em>coi != 0</em>, ROI is allocated.
Note that most of OpenCV functions do not support COI, so
to process separate image/matrix channel one may copy (via <a href="#decl_cvCopy">cvCopy</a> or
<a href="#decl_cvCvtPixToPlane">cvCvtPixToPlane</a>) the channel to separate image/matrix,
process it and copy the result back (via <a href="#decl_cvCopy">cvCopy</a> or <a href="#decl_cvCvtPlaneToPix">cvCvtPlaneToPix</a>)
if need.</p>


<hr><h3><a name="decl_cvGetImageCOI">GetImageCOI</a></h3>
<p class="Blurb">Returns index of channel of interest</p>
<pre>
int cvGetImageCOI( const IplImage* image );
</pre><p><dl>
<dt>image<dd>Image header.
</dl><p>
The function <a href="#decl_cvGetImageCOI">cvGetImageCOI</a> returns channel of interest of
the image (it returns 0 if all the channels are selected).</p>


<hr><h3><a name="decl_cvSetImageROI">SetImageROI</a></h3>
<p class="Blurb">Sets image ROI to given rectangle</p>
<pre>
void cvSetImageROI( IplImage* image, CvRect rect );
</pre><p><dl>
<dt>image<dd>Image header.
<dt>rect<dd>ROI rectangle.
</dl><p>
The function <a href="#decl_cvSetImageROI">cvSetImageROI</a> sets the image ROI to a given rectangle. If ROI is <em>NULL</em>
and the value of the parameter <em>rect</em> is not equal to the whole image, ROI is
allocated. Unlike COI, most of OpenCV functions do support ROI and treat
it in a way as it would be a separate image (for example, all the pixel
coordinates are counted from top-left or bottom-left
(depending on the image origin) corner of ROI)</p>


<hr><h3><a name="decl_cvResetImageROI">ResetImageROI</a></h3>
<p class="Blurb">Releases image ROI</p>
<pre>
void cvResetImageROI( IplImage* image );
</pre><p><dl>
<dt>image<dd>Image header.
</dl><p>
The function <a href="#decl_cvResetImageROI">cvResetImageROI</a> releases image ROI. After that the whole image
is considered selected. The similar result can be achieved by</p>
<pre>
cvSetImageROI( image, cvRect( 0, 0, image->width, image->height ));
cvSetImageCOI( image, 0 );
</pre>
<p>
But the latter variant does not deallocate <em>image->roi</em>.
</p>


<hr><h3><a name="decl_cvGetImageROI">GetImageROI</a></h3>
<p class="Blurb">Returns image ROI coordinates</p>
<pre>
CvRect cvGetImageROI( const IplImage* image );
</pre><p><dl>
<dt>image<dd>Image header.
</dl><p>
The function <a href="#decl_cvGetImageROI">cvGetImageROI</a> returns image ROI coordinates.
The rectangle <a href="#decl_cvRect">cvRect</a>(0,0,image->width,image->height) is returned if
there is no ROI</p>


<hr><h3><a name="decl_cvCreateMat">CreateMat</a></h3>
<p class="Blurb">Creates new matrix</p>
<pre>
CvMat* cvCreateMat( int rows, int cols, int type );
</pre><p><dl>
<dt>rows<dd>Number of rows in the matrix.
<dt>cols<dd>Number of columns in the matrix.
<dt>type<dd>Type of the matrix elements.
            Usually it is specified in form
            <em>CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt;</em>, for example:<br>
            <em>CV_8UC1</em> means an 8-bit unsigned single-channel matrix,
            <em>CV_32SC2</em> means a 32-bit signed matrix with two channels.
</dl><p>
The function <a href="#decl_cvCreateMat">cvCreateMat</a> allocates header for the new matrix and underlying data,
and returns a pointer to the created matrix. It is a short form for:</p>
<pre>
    CvMat* mat = cvCreateMatHeader( rows, cols, type );
    cvCreateData( mat );
</pre><p>
Matrices are stored row by row. All the rows are aligned by 4 bytes.
</p>


<hr><h3><a name="decl_cvCreateMatHeader">CreateMatHeader</a></h3>
<p class="Blurb">Creates new matrix header</p>
<pre>
CvMat* cvCreateMatHeader( int rows, int cols, int type );
</pre><p><dl>
<dt>rows<dd>Number of rows in the matrix.
<dt>cols<dd>Number of columns in the matrix.
<dt>type<dd>Type of the matrix elements (see <a href="#decl_cvCreateMat">cvCreateMat</a>).
</dl><p>
The function <a href="#decl_cvCreateMatHeader">cvCreateMatHeader</a> allocates new matrix header and returns pointer to
it. The matrix data can further be allocated using <a href="#decl_cvCreateData">cvCreateData</a> or set
explicitly to user-allocated data via <a href="#decl_cvSetData">cvSetData</a>.
</p>


<hr><h3><a name="decl_cvReleaseMat">ReleaseMat</a></h3>
<p class="Blurb">Deallocates matrix</p>
<pre>
void cvReleaseMat( CvMat** mat );
</pre><p><dl>
<dt>mat<dd>Double pointer to the matrix.
</dl><p>
The function <a href="#decl_cvReleaseMat">cvReleaseMat</a> decrements the matrix data reference counter and
releases matrix header:</p>
<pre>
    if( *mat )
        cvDecRefData( *mat );
    cvFree( (void**)mat );
</pre>
</p>


<hr><h3><a name="decl_cvInitMatHeader">InitMatHeader</a></h3>
<p class="Blurb">Initializes matrix header</p>
<pre>
void cvInitMatHeader( CvMat* mat, int rows, int cols, int type,
                      void* data=0, int step=CV_AUTOSTEP );
</pre><p><dl>
<dt>mat<dd>Pointer to the matrix header to be initialized.
<dt>rows<dd>Number of rows in the matrix.
<dt>cols<dd>Number of columns in the matrix.
<dt>type<dd>Type of the matrix elements.
<dt>data<dd>Optional data pointer assigned to the matrix header.
<dt>step<dd>Full row width in bytes of the data assigned. By default, the minimal
possible step is used, i.e., no gaps is assumed between subsequent rows of the
matrix.
</dl><p>
The function <a href="#decl_cvInitMatHeader">cvInitMatHeader</a> initializes already allocated <a href="#decl_CvMat">CvMat</a> structure. It can
be used to process raw data with OpenCV matrix functions.
<p>
For example, the following code computes matrix product of two matrices, stored
as ordinary arrays.
</p>
</p><p>
<font color=blue size=4>Calculating Product of Two Matrices</font></p>
<pre>
   double a[] = { 1, 2, 3, 4
                  5, 6, 7, 8,
                  9, 10, 11, 12 };

   double b[] = { 1, 5, 9,
                  2, 6, 10,
                  3, 7, 11,
                  4, 8, 12 };

   double c[9];
   CvMat Ma, Mb, Mc ;

   cvInitMatHeader( &Ma, 3, 4, CV_64FC1, a );
   cvInitMatHeader( &Mb, 4, 3, CV_64FC1, b );
   cvInitMatHeader( &Mc, 3, 3, CV_64FC1, c );

   cvMatMulAdd( &Ma, &Mb, 0, &Mc );
   // c array now contains product of a(3x4) and b(4x3) matrices
</pre></p>


<hr><h3><a name="decl_cvMat">Mat</a></h3>
<p class="Blurb">Initializes matrix header (light-weight variant)</p>
<pre>
CvMat cvMat( int rows, int cols, int type, void* data = 0 );
</pre><p><dl>
<dt>rows<dd>Number of rows in the matrix.
<dt>cols<dd>Number of columns in the matrix.
<dt>type<dd>Type of the matrix elements (see CreateMat).
<dt>data<dd>Optional data pointer assigned to the matrix header.
</dl><p>
The function <a href="#decl_cvMat">cvMat</a> is a fast inline substitution for <a href="#decl_cvInitMatHeader">cvInitMatHeader</a>.
Namely, it is equivalent to:
<pre>
     CvMat mat;
     cvInitMatHeader( &mat, rows, cols, type, data, CV_AUTOSTEP );
</pre>
</p>


<hr><h3><a name="decl_cvCloneMat">CloneMat</a></h3>
<p class="Blurb">Creates matrix copy</p>
<pre>
CvMat* cvCloneMat( const CvMat* mat );
</pre><p><dl>
<dt>mat<dd>Input matrix.
</dl><p>
The function <a href="#decl_cvCloneMat">cvCloneMat</a> creates a copy of input matrix and returns the pointer to
it.
</p>


<hr><h3><a name="decl_cvCreateMatND">CreateMatND</a></h3>
<p class="Blurb">Creates multi-dimensional dense array</p>
<pre>
CvMatND* cvCreateMatND( int dims, int* size, int type );
</pre><p><dl>
<dt>dims<dd>Number of array dimensions. It must not exceed CV_MAX_DIM (=16 by default,
            though it may be changed at build time)
<dt>size<dd>Array of dimension sizes.
<dt>type<dd>Type of array elements. The same as for <a href="#decl_CvMat">CvMat</a>
</dl><p>
The function <a href="#decl_cvCreateMatND">cvCreateMatND</a> allocates header for multi-dimensional dense array
and the underlying data, and returns pointer to the created array. It is a short form for:</p>
<pre>
    CvMatND* mat = cvCreateMatNDHeader( dims, size, type );
    cvCreateData( mat );
</pre><p>
Array data is stored row by row. All the rows are aligned by 4 bytes.
</p>


<hr><h3><a name="decl_cvCreateMatNDHeader">CreateMatNDHeader</a></h3>
<p class="Blurb">Creates new matrix header</p>
<pre>
CvMatND* cvCreateMatNDHeader( int dims, int* size, int type );
</pre><p><dl>
<dt>dims<dd>Number of array dimensions.
<dt>size<dd>Array of dimension sizes.
<dt>type<dd>Type of array elements. The same as for CvMat
</dl><p>
The function <a href="#decl_cvCreateMatND">cvCreateMatND</a> allocates header for multi-dimensional dense array.
The array data can further be allocated using <a href="#decl_cvCreateData">cvCreateData</a> or set
explicitly to user-allocated data via <a href="#decl_cvSetData">cvSetData</a>.
</p>


<hr><h3><a name="decl_cvReleaseMatND">ReleaseMatND</a></h3>
<p class="Blurb">Deallocates multi-dimensional array</p>
<pre>
void cvReleaseMatND( CvMatND** mat );
</pre><p><dl>
<dt>mat<dd>Double pointer to the array.
</dl><p>
The function <a href="#decl_cvReleaseMatND">cvReleaseMatND</a> decrements the array data reference counter and
releases the array header:</p>
<pre>
    if( *mat )
        cvDecRefData( *mat );
    cvFree( (void**)mat );
</pre>
</p>


<hr><h3><a name="decl_cvInitMatNDHeader">InitMatNDHeader</a></h3>
<p class="Blurb">Initializes multi-dimensional array header</p>
<pre>
void cvInitMatNDHeader( CvMatND* mat, int dims, int* size, int type, void* data=0 );
</pre><p><dl>
<dt>mat<dd>Pointer to the array header to be initialized.
<dt>rows<dd>Number of rows in the matrix.
<dt>cols<dd>Number of columns in the matrix.
<dt>type<dd>Type of the matrix elements.
<dt>data<dd>Optional data pointer assigned to the matrix header.
</dl><p>
The function <a href="#decl_cvInitMatNDHeader">cvInitMatNDHeader</a> initializes already allocated <a href="#decl_CvMatND">CvMatND</a> structure.
</p>

<hr><h3><a name="decl_cvCloneMatND">CloneMatND</a></h3>
<p class="Blurb">Creates full copy of multi-dimensional array</p>
<pre>
CvMatND* cvCloneMatND( const CvMatND* mat );
</pre><p><dl>
<dt>mat<dd>Input array.
</dl><p>
The function <a href="#decl_cvCloneMatND">cvCloneMatND</a> creates a copy of input array and returns pointer to
it.
</p>


<hr><h3><a name="decl_cvDecRefData">DecRefData</a></h3>
<p class="Blurb">Decrements array data reference counter</p>
<pre>
void cvDecRefData( CvArr* array );
</pre><p><dl>
<dt>array<dd>array header.
</dl><p>
The function <a href="#decl_cvDecRefData">cvDecRefData</a> decrements <a href="#decl_CvMat">CvMat</a> or <a href="#decl_CvMatND">CvMatND</a> data reference counter if the
reference counter pointer is not NULL and deallocates the data if the counter reaches zero.
In the current implementation the reference counter is not NULL only if the data was allocated using
<a href="#decl_cvCreateData">cvCreateData</a> function, in other cases such as:<br>
external data was assigned to the header using <a href="#decl_cvSetData">cvSetData</a><br>
the matrix header presents a part of a larger matrix or image<br>
the matrix header was converted from image or n-dimensional matrix header<br>
<br>
the reference counter is set to NULL and thus it is not decremented.
Whenever the data is deallocated or not,
the data pointer and reference counter pointers are cleared by the function.
</p>


<hr><h3><a name="decl_cvIncRefData">IncRefData</a></h3>
<p class="Blurb">Increments array data reference counter</p>
<pre>
int cvIncRefData( CvArr* array );
</pre><p><dl>
<dt>array<dd>array header.
</dl><p>
The function <a href="#decl_cvIncRefData">cvIncRefData</a> increments <a href="#decl_CvMat">CvMat</a> or <a href="#decl_CvMatND">CvMatND</a> data reference counter and
returns the new counter value if the reference counter pointer is not NULL, otherwise it returns zero.
</p>


<hr><h3><a name="decl_cvCreateData">CreateData</a></h3>
<p class="Blurb">Allocates array data</p>
<pre>
void cvCreateData( CvArr* array );
</pre><p><dl>
<dt>array<dd>Array header.
</dl></p><p>
The function <a href="#decl_cvCreateData">cvCreateData</a> allocates image, matrix or multi-dimensional array data.
Note that in case of matrix types OpenCV allocation functions are used and
in case of IplImage they are used too unless <em>CV_TURN_ON_IPL_COMPATIBILITY</em> was called.
In the latter case IPL functions are used to allocate the data
</p>


<hr><h3><a name="decl_cvReleaseData">ReleaseData</a></h3>
<p class="Blurb">Releases array data</p>
<pre>
void cvReleaseData( CvArr* array );
</pre><p><dl>
<dt>array<dd>Array header
</dl><p>
The function <a href="#decl_cvReleaseData">cvReleaseData</a> releases the array data.
In case of <a href="#decl_CvMat">CvMat</a> or <a href="#decl_CvMatND">CvMatND</a> it simply calls cvDecRefData(), that is
the function can not deallocate external data. See also the note to <a href="#decl_cvCreateData">cvCreateData</a>.
</p>


<hr><h3><a name="decl_cvSetData">SetData</a></h3>
<p class="Blurb">Assigns user data to the array header</p>
<pre>
void cvSetData( CvArr* array, void* data, int step );
</pre><p><dl>
<dt>array<dd>Array header.
<dt>data<dd>User data.
<dt>step<dd>Full row length in bytes.
</dl><p>
The function <a href="#decl_cvSetData">cvSetData</a> assigns user data to the array header.
Header should be initialized before using cvCreate*Header,
cvInit*Header or <a href="#decl_cvMat">cvMat</a> (in case of matrix) function.
</p>


<hr><h3><a name="decl_cvGetRawData">GetRawData</a></h3>
<p class="Blurb">Retrieves low-level information about the array</p>
<pre>
void cvGetRawData( const CvArr* array, uchar** data,
                   int* step, CvSize* roiSize );
</pre><p><dl>
<dt>array<dd>Array header.
<dt>data<dd>Output pointer to the whole image origin or ROI origin if
ROI is set.
<dt>step<dd>Output full row length in bytes.
<dt>roiSize<dd>Output ROI size.
</dl><p>
The function <a href="#decl_cvGetRawData">cvGetRawData</a> fills output variables with low-level
information about the array data.
All output parameters are optional, so some of the pointers
may be set to <em>NULL</em>.
If the array is <em>IplImage</em> with ROI set,
parameters of ROI are returned.
</p>
<p>The following example shows how to get access to array elements using
this function.</p>
<p>
<font color=blue size=4>Using GetRawData to calculate absolute value of elements of
a single-channel floating-point array.</font>
<pre>
    float* data;
    int step;

    CvSize size;
    int x, y;

    cvGetRawData( array, (uchar**)&data, &step, &size );
    step /= sizeof(data[0]);

    for( y = 0; y &lt; size.height; y++, data += step )
        for( x = 0; x &lt; size.width; x++ )
            data[x] = (float)fabs(data[x]);
</pre></p>


<hr><h3><a name="decl_cvGetMat">GetMat</a></h3>
<p class="Blurb">Returns matrix header for arbitrary array</p>
<pre>
CvMat* cvGetMat( const CvArr* arr, CvMat* mat, int* coi = 0, int allowND );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>mat<dd>Pointer to <a href="#decl_CvMat">CvMat</a> structure used as a temporary buffer.
<dt>coi<dd>Optional output parameter for storing COI.
<dt>allowND<dd>If non-zero, the function accepts multi-dimensional dense
              arrays (CvMatND*) and returns 2D (if CvMatND has two dimensions)
              or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions).
              The array must be continuous.
</dl><p>
The function <a href="#decl_cvGetMat">cvGetMat</a> returns matrix header for the input array that can be
matrix - <a href="#decl_CvMat*">CvMat*</a>, image - <em>IplImage*</em> or multi-dimensional dense array - <a href="#decl_CvMatND*">CvMatND*</a>
(latter case is allowed only if <em>allowND != 0</em>) .
In the case of matrix the function simply returns the input pointer.
In the case of <em>IplImage*</em> or <a href="#decl_CvMatND*">CvMatND*</a> it initializes <em>mat</em> structure
with parameters of the current image ROI and returns pointer to this temporary
structure. Because COI is not supported by <a href="#decl_CvMat">CvMat</a>, it is returned separately.
<p>
The function provides an easy way to handle both types of array - <em>IplImage</em> and
<a href="#decl_CvMat">CvMat</a> -, using the same code. Reverse transform from <a href="#decl_CvMat">CvMat</a> to <em>IplImage</em> can be
done using <a href="#decl_cvGetImage">cvGetImage</a> function.
</p><p>
Input array must have underlying data allocated or attached, otherwise the
function fails.
</p>
If the input array is <em>IplImage</em> with planar data layout and COI set, the function
returns pointer to the selected plane and COI = 0. It enables per-plane
processing of multi-channel images with planar data layout using OpenCV
functions.</p>


<hr><h3><a name="decl_cvGetImage">GetImage</a></h3>
<p class="Blurb">Returns image header for arbitrary array</p>
<pre>
IplImage* cvGetImage( const CvArr* arr, IplImage* image_header );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>image_header<dd>Pointer to <em>IplImage</em> structure used as a temporary buffer.
</dl><p>
The function <a href="#decl_cvGetImage">cvGetImage</a> returns image header for the input array that can be
matrix - <a href="#decl_CvMat*">CvMat*</a>, or image - <em>IplImage*</em>. In the case of image the function simply
returns the input pointer. In the case of <a href="#decl_CvMat*">CvMat*</a> it initializes <em>image_header</em> structure
with parameters of the input matrix. Note that if we transform <em>IplImage</em> to <a href="#decl_CvMat">CvMat</a> and then transform
CvMat back to IplImage, we can get different headers if the ROI is set, and thus some IPL functions
that calculate image stride from its width and align may fail on the resultant image.</p>


<hr><h3><a name="decl_cvGetSubRect">GetSubRect</a></h3>
<p class="Blurb">Returns matrix header corresponding to the rectangular sub-array of input image or matrix</p>
<pre>
CvMat* cvGetSubRect( const CvArr* array, CvMat* subarr, CvRect rect );
</pre><p><dl>
<dt>array<dd>Input array.
<dt>subarr<dd>Pointer to the resultant subarray header.
<dt>rect<dd>Zero-based coordinates of the rectangle of interest.
</dl><p>
The function <a href="#decl_cvGetSubRect">cvGetSubRect</a> returns header, corresponding to a specified rectangle of
the input array. In other words, it allows the user to treat a rectangular part
of input array as a stand-alone array. ROI is taken into account by the function
so the sub-array of ROI is really extracted.</p>


<hr><h3><a name="decl_cvGetRow">GetRow, GetRows</a></h3>
<p class="Blurb">Returns array row or row span</p>
<pre>
CvMat* cvGetRow( const CvArr* arr, CvMat* subarr, int row );
CvMat* cvGetRows( const CvArr* arr, CvMat* subarr, int start_row, end_row );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>subarr<dd>Pointer to the resulting sub-array header.
<dt>row<dd>Zero-based index of the selected row.
<dt>start_row<dd>Zero-based index of the starting row (inclusive) of the span.
<dt>end_row<dd>Zero-based index of the ending row (exclusive) of the span.
</dl><p>
The functions <em>GetRow</em> and <em>GetRows</em> return the header, corresponding to a specified
row/row span of the input array. Note that <em>GetRow</em> is a shortcut for <a href="#decl_cvGetRows">cvGetRows</a>:
<pre>
cvGetRow( arr, subarr, row ); // ~ cvGetRows( arr, subarr, row, row + 1 );
</pre></p>


<hr><h3><a name="decl_cvGetCol">GetCol, GetCols</a></h3>
<p class="Blurb">Returns array column or column span</p>
<pre>
CvMat* cvGetCol( const CvArr* arr, CvMat* subarr, int col );
CvMat* cvGetCols( const CvArr* arr, CvMat* subarr, int start_col, end_col );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>subarr<dd>Pointer to the resulting sub-array header.
<dt>col<dd>Zero-based index of the selected column.
<dt>start_col<dd>Zero-based index of the starting column (inclusive) of the span.
<dt>end_col<dd>Zero-based index of the ending column (exclusive) of the span.
</dl><p>
The functions <em>GetCol</em> and <em>GetCols</em> return the header, corresponding to a specified
column/column span of the input array. Note that <em>GetCol</em> is a shortcut for <a href="#decl_cvGetCols">cvGetCols</a>:
<pre>
cvGetCol( arr, subarr, col ); // ~ cvGetCols( arr, subarr, col, col + 1 );
</pre></p>


<hr><h3><a name="decl_cvGetDiag">GetDiag</a></h3>
<p class="Blurb">Returns one of array diagonals</p>
<pre>
CvMat* cvGetDiag( const CvArr* arr, CvMat* subarr, int diag=0 );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>subarr<dd>Pointer to the resulting sub-array header.
<dt>diag<dd>Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above
the main etc., 1 corresponds to the diagonal below the main etc.
</dl><p>
The function <a href="#decl_cvGetDiag">cvGetDiag</a> returns the header, corresponding to a specified
diagonal of the input array.</p>


<hr><h3><a name="decl_cvGetSize">GetSize</a></h3>
<p class="Blurb">Returns size of matrix or image ROI</p>
<pre>
CvSize cvGetSize( const CvArr* arr );
</pre><p><dl>
<dt>arr<dd>array header.
</dl><p>
The function <a href="#decl_cvGetSize">cvGetSize</a> returns number of rows (CvSize::height) and number of columns
(CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.</p>


<hr><h3><a name="decl_cvCreateSparseMat">CreateSparseMat</a></h3>
<p class="Blurb">Creates sparse array</p>
<pre>
CvSparseMat* cvCreateSparseMat( int dims, int* size, int type );
</pre><p><dl>
<dt>dims<dd>Number of array dimensions. It must not exceed CV_MAX_DIM (=16 by default,
            though it may be changed at build time)
<dt>size<dd>Array of dimension sizes.
<dt>type<dd>Type of array elements. The same as for CvMat
</dl><p>
The function <a href="#decl_cvCreateSparseMat">cvCreateSparseMat</a> allocates multi-dimensional sparse array.
Initially the array contain no elements, that is cvGet*D will return zero for every index</p>


<hr><h3><a name="decl_cvReleaseSparseMat">ReleaseSparseMat</a></h3>
<p class="Blurb">Deallocates sparse array</p>
<pre>
void cvReleaseSparseMat( CvSparseMat** mat );
</pre><p><dl>
<dt>mat<dd>Double pointer to the array.
</dl><p>
The function <a href="#decl_cvReleaseSparseMat">cvReleaseSparseMat</a> releases the sparse array and clears the array pointer upon exit</p>


<hr><h3><a name="decl_cvCloneSparseMat">CloneSparseMat</a></h3>
<p class="Blurb">Creates full copy of sparse array</p>
<pre>
CvSparseMat* cvCloneSparseMat( const CvSparseMat* mat );
</pre><p><dl>
<dt>mat<dd>Input array.
</dl><p>
The function <a href="#decl_cvCloneSparseMat">cvCloneSparseMat</a> creates a copy of the input array and returns pointer to the copy.</p>


<hr><h3><a name="decl_cvInitSparseMatIterator">InitSparseMatIterator</a></h3>
<p class="Blurb">Initializes sparse array elements iterator</p>
<pre>
CvSparseMat* cvInitSparseMatIterator( const CvSparseMat* mat, CvSparseMatIterator* matIterator );
</pre><p><dl>
<dt>mat<dd>Input array.
<dt>matIterator<dd>Initialized iterator.
</dl><p>
The function <a href="#decl_cvInitSparseMatIterator">cvInitSparseMatIterator</a> initializes iterator of sparse array elements and
returns pointer to the first element, or NULL if the array is empty.</p>


<hr><h3><a name="decl_cvGetNextSparseNode">GetNextSparseNode</a></h3>
<p class="Blurb">Initializes sparse array elements iterator</p>
<pre>
CvSparseMat* cvGetNextSparseNode( CvSparseMatIterator* matIterator );
</pre><p><dl>
<dt>matIterator<dd>Sparse array iterator.
</dl><p>
The function <a href="#decl_cvGetNextSparseNode">cvGetNextSparseNode</a> moves iterator to the next sparse matrix element and returns
pointer to it. In the current version there is no any particular order of the elements, because they
are stored in hash table. The sample below demonstrates how to iterate through the sparse matrix:</p>
<p>
<font color=blue size=4>Using <a href="#decl_cvInitSparseMatIterator">cvInitSparseMatIterator</a> and <a href="#decl_cvGetNextSparseNode">cvGetNextSparseNode</a> to calculate sum of
floating-point sparse array.</font>
<pre>
    double sum;
    int i, dims = cvGetDims( array );
    CvSparseMatIterator matIterator;
    CvSparseNode* node = cvInitSparseMatIterator( array, &matIterator );

    for( ; node != 0; node = cvGetNextSparseNode( &matIterator ))
    {
        int* idx = CV_NODE_IDX( array, node ); /* get pointer to the element indices */
        float val = (float*)CV_NODE_VAL( array, node ); /* get value of the element
                                                          (assume that the type is CV_32FC1) */
        printf( "(" );
        for( i = 0; i &lt; dims; i++ )
            printf( "%4d%s", idx[i], i &lt; dims - 1 "," : "): " );
        printf( "%g\n", val );

        sum += val;
    }

    printf( "\nTotal sum = %g\n", sum );
</pre></p>

<hr><h3><a name="decl_cvGetElemType">GetElemType</a></h3>
<p class="Blurb">Returns type of array elements</p>
<pre>
int cvGetElemType( const CvArr* arr );
</pre><p><dl>
<dt>arr<dd>Input array.
</dl><p>
The functions <em>GetElemType</em> returns type of the array elements as it is described in
cvCreateMat discussion: <pre>CV_8UC1 ... CV_64FC4</pre></p>


<hr><h3><a name="decl_cvGetDims">GetDims, GetDimSize</a></h3>
<p class="Blurb">Return number of array dimensions and their sizes or the size of particular dimension</p>
<pre>
int cvGetDims( const CvArr* arr, int* size=0 );
int cvGetDimSize( const CvArr* arr, int index );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>size<dd>Optional output vector of the array dimension sizes. For 2d arrays the number of rows (height)
goes first, number of columns (width) next.
<dt>index<dd>Zero-based dimension index (for matrices 0 means number of rows, 1 means number of columns;
for images 0 means height, 1 means width).
</dl><p>
The function <a href="#decl_cvGetDims">cvGetDims</a> returns number of array dimensions and their sizes.
In case of <em>IplImage</em> or <a href="#decl_CvMat">CvMat</a> it always returns 2 regardless of number of image/matrix rows.
The function <a href="#decl_cvGetDimSize">cvGetDimSize</a> returns the particular dimension size (number of elements per that dimension).
For example, the following code calculates total number of array elements:<pre>

// via cvGetDims()
int size[CV_MAX_DIM];
int i, total = 1;
int dims = cvGetDims( arr, size );
for( i = 0; i &lt; dims; i++ )
    total *= size[i];

// via cvGetDims() and cvGetDimSize()
int i, total = 1;
int dims = cvGetDims( arr );
for( i = 0; i &lt; dims; i++ )
    total *= cvGetDimsSize( arr, i );
</pre>
</p>


<hr><h3><a name="decl_cvPtr*D">Ptr*D</a></h3>
<p class="Blurb">Return pointer to the particular array element</p>
<pre>
uchar* cvPtr1D( const CvArr* arr, int idx0, int* type=0 );
uchar* cvPtr2D( const CvArr* arr, int idx0, int idx1, int* type=0 );
uchar* cvPtr3D( const CvArr* arr, int idx0, int idx1, int idx2, int* type=0 );
uchar* cvPtrND( const CvArr* arr, int* idx, int* type=0 );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>idx0<dd>The first zero-based component of the element index
<dt>idx1<dd>The second zero-based component of the element index
<dt>idx2<dd>The third zero-based component of the element index
<dt>idx<dd>Array of the element indices
<dt>type<dd>Optional output parameter: type of matrix elements
</dl><p>
The functions <a href="#decl_cvPtr*D">cvPtr*D</a> return pointer to the particular array element.
Number of array dimension should match to the number of indices passed to the function except
for <a href="#decl_cvPtr1D">cvPtr1D</a> function that can be used for sequential access to 1D, 2D or nD dense arrays.
</p><p>
The functions can be used for sparse arrays as well - if the requested node does not exist they
create it and set it to zero.</p><p>
All these as well as other functions accessing array elements (<a href="#decl_cvGet[Real]*D">cvGet[Real]*D</a>, <a href="#decl_cvSet[Real]*D">cvSet[Real]*D</a>)
raise an error in case if the element index is out of range.
</p>


<hr><h3><a name="decl_cvGet*D">Get*D</a></h3>
<p class="Blurb">Return the particular array element</p>
<pre>
CvScalar cvGet1D( const CvArr* arr, int idx0 );
CvScalar cvGet2D( const CvArr* arr, int idx0, int idx1 );
CvScalar cvGet3D( const CvArr* arr, int idx0, int idx1, int idx2 );
CvScalar cvGetND( const CvArr* arr, int* idx );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>idx0<dd>The first zero-based component of the element index
<dt>idx1<dd>The second zero-based component of the element index
<dt>idx2<dd>The third zero-based component of the element index
<dt>idx<dd>Array of the element indices
</dl><p>
The functions <a href="#decl_cvGet*D">cvGet*D</a> return the particular array element. In case of sparse array
the functions return 0 if the requested node does not exist (no new node is created
by the functions)</p>


<hr><h3><a name="decl_cvGetReal*D">GetReal*D</a></h3>
<p class="Blurb">Return the particular element of single-channel array</p>
<pre>
double cvGetReal1D( const CvArr* arr, int idx0 );
double cvGetReal2D( const CvArr* arr, int idx0, int idx1 );
double cvGetReal3D( const CvArr* arr, int idx0, int idx1, int idx2 );
double cvGetRealND( const CvArr* arr, int* idx );
</pre><p><dl>
<dt>arr<dd>Input array. Must have a single channel.
<dt>idx0<dd>The first zero-based component of the element index
<dt>idx1<dd>The second zero-based component of the element index
<dt>idx2<dd>The third zero-based component of the element index
<dt>idx<dd>Array of the element indices
</dl><p>
The functions <a href="#decl_cvGetReal*D">cvGetReal*D</a> return the particular element of single-channel array.
If the array has multiple channels, runtime error is raised. Note that <a href="#decl_cvGet*D">cvGet*D</a> function
can be used safely for both single-channel and multiple-channel arrays though they are
a bit slower.</p><p>In case of sparse array
the functions return 0 if the requested node does not exist (no new node is created
by the functions)</p>


<hr><h3><a name="decl_cvmGet">mGet</a></h3>
<p class="Blurb">Return the particular element of single-channel floating-point matrix</p>
<pre>
double cvmGet( const CvMat* mat, int row, int col );
</pre><p><dl>
<dt>mat<dd>Input matrix.
<dt>row<dd>The zero-based index of row.
<dt>col<dd>The zero-based index of column.
</dl><p>
The function <a href="#decl_cvmGet">cvmGet</a> is a fast replacement for <a href="#decl_cvGetReal2D">cvGetReal2D</a> in case of
single-channel floating-point matrices. It is faster because it is inline,
it does less checks for array type and array element type and it
checks for the row and column ranges only in debug mode.</p>


<hr><h3><a name="decl_cvSet*D">Set*D</a></h3>
<p class="Blurb">Change the particular array element</p>
<pre>
void cvSet1D( CvArr* arr, int idx0, CvScalar new_value );
void cvSet2D( CvArr* arr, int idx0, int idx1, CvScalar new_value );
void cvSet3D( CvArr* arr, int idx0, int idx1, int idx2, CvScalar new_value );
void cvSetND( CvArr* arr, int* idx, CvScalar new_value );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>idx0<dd>The first zero-based component of the element index
<dt>idx1<dd>The second zero-based component of the element index
<dt>idx2<dd>The third zero-based component of the element index
<dt>idx<dd>Array of the element indices
<dt>new_value<dd>The assigned value
</dl><p>
The functions <a href="#decl_cvSet*D">cvSet*D</a> assign the new value to the particular element of array.
In case of sparse array the functions create the node if it does not exist yet</p>


<hr><h3><a name="decl_cvSetReal*D">SetReal*D</a></h3>
<p class="Blurb">Change the particular array element</p>
<pre>
void cvSetReal1D( CvArr* arr, int idx0, double new_value );
void cvSetReal2D( CvArr* arr, int idx0, int idx1, double new_value );
void cvSetReal3D( CvArr* arr, int idx0, int idx1, int idx2, double new_value );
void cvSetRealND( CvArr* arr, int* idx, double new_value );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>idx0<dd>The first zero-based component of the element index
<dt>idx1<dd>The second zero-based component of the element index
<dt>idx2<dd>The third zero-based component of the element index
<dt>idx<dd>Array of the element indices
<dt>new_value<dd>The assigned value
</dl><p>
The functions <a href="#decl_cvSetReal*D">cvSetReal*D</a> assign the new value to the particular element of single-channel array.
If the array has multiple channels, runtime error is raised. Note that <a href="#decl_cvSet*D">cvSet*D</a> function
can be used safely for both single-channel and multiple-channel arrays though they are
a bit slower.</p>
<p>In case of sparse array the functions create the node if it does not exist yet</p>


<hr><h3><a name="decl_cvmSet">mSet</a></h3>
<p class="Blurb">Return the particular element of single-channel floating-point matrix</p>
<pre>
void cvmSet( CvMat* mat, int row, int col, double value );
</pre><p><dl>
<dt>mat<dd>The matrix.
<dt>row<dd>The zero-based index of row.
<dt>col<dd>The zero-based index of column.
<dt>value<dd>The new value of the matrix element
</dl><p>
The function <a href="#decl_cvmSet">cvmSet</a> is a fast replacement for <a href="#decl_cvSetReal2D">cvSetReal2D</a> in case of
single-channel floating-point matrices. It is faster because it is inline,
it does less checks for array type and array element type and it
checks for the row and column ranges only in debug mode.</p>


<hr><h3><a name="decl_cvClear*D">Clear*D</a></h3>
<p class="Blurb">Clears the particular array element</p>
<pre>
void cvClearND( CvArr* arr, int* idx );
</pre><p><dl>
<dt>arr<dd>Input array.
<dt>idx<dd>Array of the element indices
</dl><p>
The function <a href="#decl_cvClear*D">cvClearND</a> clears (sets to zero)
the particular element of dense array or deletes the element of sparse array.
If the element does not exists, the function does nothing.</p>


<hr><h3><a name="decl_cvCopy">Copy</a></h3>
<p class="Blurb">Copies one array to another</p>
<pre>
void cvCopy( const CvArr* A, CvArr* B, const CvArr* mask =0);
</pre><p><dl>
<dt>A<dd>The source array.
<dt>B<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvCopy">cvCopy</a> copies selected elements from input array to output array:</p>
<p>
B(I)=A(I) if mask(I)!=0.
</p><p>If any of the passed arrays is of <em>IplImage</em> type, then its ROI and COI fields are
used. Both arrays must have the same type, the same number of dimensions and the same size.
The function can also copy sparse arrays (mask is not supported in this case).</p>


<hr><h3><a name="decl_cvSet">Set</a></h3>
<p class="Blurb">Sets every element of array to given value</p>
<pre>
void cvSet( CvArr* A, CvScalar S, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The destination array.
<dt>S<dd>Fill value.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvSet">cvSet</a> copies scalar <em>S</em> to every selected element of the destination
array:</p>
<pre>A(I)=S if mask(I)!=0</pre>
<p>If array <em>A</em> is of <em>IplImage</em> type, then is ROI used, but COI must not be
set.</p>


<hr><h3><a name="decl_cvSetZero">SetZero</a></h3>
<p class="Blurb">Clears the array</p>
<pre>
void cvSetZero( CvArr* arr );
#define cvZero cvSetZero
</pre><p><dl>
<dt>arr<dd>array to be cleared.
</dl><p>
The function <a href="#decl_cvSetZero">cvSetZero</a> clears the array. In case of dense arrays (CvMat, CvMatND or IplImage)
cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), but the function can clear sparse arrays
by removing all the array elements</p>



<!-- *****************************************************************************************
     *****************************************************************************************
     ***************************************************************************************** -->


<hr><h2><a name="ch1_array_basic">Arrays: Conversions, transformations, basic operations </a></h2>


<hr><h3><a name="decl_cvReshape">Reshape</a></h3>
<p class="Blurb">Changes shape of matrix/image without copying data</p>
<pre>
CvMat* cvReshape( const CvArr* array, CvMat* header, int new_cn, int new_rows=0 );
</pre><p><dl>
<dt>array<dd>Input array.
<dt>header<dd>Output header to be filled.
<dt>new_cn<dd>New number of channels. <em>new_cn = 0</em> means that number of channels remains unchanged.
<dt>new_rows<dd>New number of rows. <em>new_rows = 0</em> means that number of rows remains unchanged unless
it needs to be changed according to <em>new_cn</em> value.
destination array to be changed.
</dl><p>
The function <a href="#decl_cvReshape">cvReshape</a> initializes CvMat header so that it points to the same data as
the original array but has different shape - different number of channels,
different number of rows or both.</p><p>For example, the following code creates one image buffer and
two image headers, first is for 320x240x3 image and the second is for 960x240x1 image:</p>
<pre>
IplImage* color_img = cvCreateImage( cvSize(320,240), IPL_DEPTH_8U, 3 );
CvMat gray_mat_hdr;
IplImage gray_img_hdr, *gray_img;
cvReshape( color_img, &gray_mat_hdr, 1 );
gray_img = cvGetImage( &gray_mat_hdr, &gray_img_hdr );
</pre>
<p>And the next example converts 3x3 matrix to a single 1x9 vector</p>
<pre>
CvMat* mat = cvCreateMat( 3, 3, CV_32F );
CvMat row_header, *row;
row = cvReshape( mat, &row_header, 0, 1 );
</pre>


<hr><h3><a name="decl_cvReshapeMatND">ReshapeMatND</a></h3>
<p class="Blurb">Changes shape of multi-dimensional array w/o copying data</p>
<pre>
CvArr* cvReshapeMatND( const CvArr* array,
                       int sizeof_header, CvArr* header,
                       int new_cn, int new_dims, int* new_sizes );

#define cvReshapeND( arr, header, new_cn, new_dims, new_sizes )   \
      cvReshapeMatND( (arr), sizeof(*(header)), (header),         \
                      (new_cn), (new_dims), (new_sizes))

</pre><p><dl>
<dt>array<dd>Input array.
<dt>sizeof_header<dd>Size of output header to distinguish between IplImage, CvMat and CvMatND output headers.
<dt>header<dd>Output header to be filled.
<dt>new_cn<dd>New number of channels. <em>new_cn = 0</em> means that number of channels remains unchanged.
<dt>new_dims<dd>New number of dimensions. <em>new_dims = 0</em> means that number of dimensions remains the same.
<dt>new_sizes<dd>Array of new dimension sizes. Only <em>new_dims-1</em> values are used, because the total number of
elements must remain the same. Thus, if <em>new_dims = 1</em>, <em>new_sizes</em> array is not used
</dl><p>
The function <a href="#decl_cvReshapeMatND">cvReshapeMatND</a> is an advanced version of <a href="#decl_cvReshape">cvReshape</a> that can work
with multi-dimensional arrays as well (though, it can work with ordinary images and matrices)
and change the number of dimensions. Below are the two samples
from the <a href="#decl_cvReshape">cvReshape</a> description rewritten using <a href="#decl_cvReshapeMatND">cvReshapeMatND</a>:</p>
<pre>
IplImage* color_img = cvCreateImage( cvSize(320,240), IPL_DEPTH_8U, 3 );
IplImage gray_img_hdr, *gray_img;
gray_img = (IplImage*)cvReshapeND( color_img, &gray_img_hdr, 1, 0, 0 );

...

/* second example is modified to convert 2x2x2 array to 8x1 vector */
int size[] = { 2, 2, 2 };
CvMatND* mat = cvCreateMatND( 3, size, CV_32F );
CvMat row_header, *row;
row = cvReshapeND( mat, &row_header, 0, 1, 0 );
</pre>


<hr><h3><a name="decl_cvRepeat">Repeat</a></h3>
<p class="Blurb">Fill destination array with tiled source array</p>
<pre>
void cvRepeat( const CvArr* A, CvArr* B );
</pre><p><dl>
<dt>A<dd>Source array, image or matrix.
<dt>B<dd>Destination array, image or matrix.
</dl><p>
The function <a href="#decl_cvRepeat">cvRepeat</a> fills the destination array with source array tiled:</p>
<pre>B(i,j)=A(i%rows(A), j%cols(A))</pre>
<p>where "%" means "modulo" operation.
So the destination array may be as larger as well as smaller than
the source array.
</p>


<hr><h3><a name="decl_cvFlip">Flip</a></h3>
<p class="Blurb">Flip a 2D array around vertical, horizontall or both axises</p>
<pre>
void  cvFlip( const CvArr* A, CvArr* B=0, int flip_mode=0);
#define cvMirror cvFlip

</pre><p><dl>
<dt>A<dd>Source array.
<dt>B<dd>Destination array. If <em>dst = NULL</em> the flipping is done inplace.
<dt>flip_mode<dd>Specifies how to flip the array.<br>
                 flip_mode = 0 means flipping around x-axis,
                 flip_mode > 0 (e.g. 1) means flipping around y-axis
                 and flip_mode &lt; 0 (e.g. -1) means flipping around both axises.
                 See also the discussion below for the formulas
</dl><p>
The function <a href="#decl_cvFlip">cvFlip</a> flips the array in one of different 3 ways
(row and column indices are 0-based):</p>
<pre>B(i,j)=A(rows(A)-i-1,j) if flip_mode = 0</pre>
<pre>B(i,j)=A(i,cols(A)-j-1) if flip_mode > 0</pre>
<pre>B(i,j)=A(rows(A)-i-1,cols(A)-j-1) if flip_mode &lt; 0</pre>
<p>The typical scenaria
of the function use are:
<ul>
<li>
vertical flipping of the image (flip_mode > 0) to switch between top-left
and bottom-left image origin, which is typical operation in video processing under Win32 systems.</li>
<li>
horizontal flipping of the image with subsequent horizontal shift and absolute difference calculation
to check for a vertical-axis symmetry (flip_mode > 0)</li>
<li>
simultaneous horizontal and vertical flipping of the image with subsequent shift and
absolute difference calculation to check for a central symmetry (flip_mode &lt; 0)</li>
<li>reversing the order of 1d point arrays(flip_mode > 0)</li>
</ul></p>


<hr><h3><a name="decl_cvCvtPixToPlane">CvtPixToPlane</a></h3>
<p class="Blurb">Divides multi-channel array into several single-channel arrays or extracts
a single channel from the array</p>
<pre>
void cvCvtPixToPlane( const CvArr* src, CvArr* dst0, CvArr* dst1,
                      CvArr* dst2, CvArr* dst3 );
</pre><p><dl>
<dt>src<dd>Source array.
<dt>dst0...dst3<dd>Destination channels.
</dl><p>
The function <a href="#decl_cvCvtPixToPlane">cvCvtPixToPlane</a> divides a multi-channel array into separate single-channel arrays.
Two modes are available for the operation. If the source array has N channels then if
the first N destination channels are not NULL, all they are extracted from the source array,
otherwise if only a single destination channel of the first N is not NULL, this particular channel
is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N)
must always be NULL.
For IplImage <a href="#decl_cvCopy">cvCopy</a> with COI set can be also used to extract a single channel from the image.</p>


<hr><h3><a name="decl_cvCvtPlaneToPix">CvtPlaneToPix</a></h3>
<p class="Blurb">Composes multi-channel array from several single-channel arrays or inserts a
single channel into the array</p>
<pre>
void cvCvtPlaneToPix( const CvArr* src0, const CvArr* src1,
                      const CvArr* src2, const CvArr* src3, CvArr* dst );
</pre><p><dl>
<dt>src0... src3<dd>Input channels.
<dt>dst<dd>Destination array.
</dl><p>
The function <a href="#decl_cvCvtPlaneToPix">cvCvtPlaneToPix</a> is the opposite to the previous.
If the destination array has N channels then if
the first N input channels are not NULL, all they are copied to the destination array,
otherwise if only a single source channel of the first N is not NULL, this particular channel is copied
into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N)
must always be NULL.
For IplImage <a href="#decl_cvCopy">cvCopy</a> with COI set can be also used to insert a single channel into the image.
</p>


<hr><h3><a name="decl_cvConvertScale">ConvertScale</a></h3>
<p class="Blurb">Converts one array to another with optional linear transformation</p>
<pre>
void cvConvertScale( const CvArr* A, CvArr* B, double scale=1, double shift=0 );

#define cvCvtScale cvConvertScale
#define cvScale  cvConvertScale
#define cvConvert( A, B )  cvConvertScale( (A), (B), 1, 0 )
</pre><p><dl>
<dt>A<dd>Source array.
<dt>B<dd>Destination array.
<dt>scale<dd>Scale factor.
<dt>shift<dd>Value added to the scaled source array elements.
</dl><p>
The function <a href="#decl_cvConvertScale">cvConvertScale</a> has several different purposes and thus has several synonyms.
It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:</p>
<pre>B(I)=A(I)*scale + (shift,shift,...)</pre>
<p>All the channels of multi-channel arrays are processed independently.</p><p>
The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not
be represented exactly by a value of destination array element type, it is set to the nearest
representable value on the real axis.</p>
<p>In case of <em>scale=1, shift=0</em> no prescaling is done. This is a specially optimized case and it
has the appropriate <a href="#decl_cvConvert">cvConvert</a> synonym. If source and destination array types have
equal types, this is also a special case that can be used to scale and shift a matrix or an image and
that fits to <a href="#decl_cvScale">cvScale</a> synonym.</p>


<hr><h3><a name="decl_cvConvertScaleAbs">ConvertScaleAbs</a></h3>
<p class="Blurb">Converts input array elements to 8-bit unsigned integer another with optional linear transformation</p>
<pre>
void cvConvertScaleAbs( const CvArr* A, CvArr* B, double scale=1, double shift=0 );
#define cvCvtScaleAbs cvConvertScaleAbs

</pre><p><dl>
<dt>A<dd>Source array.
<dt>B<dd>Destination array (should have 8u depth).
<dt>scale<dd>ScaleAbs factor.
<dt>shift<dd>Value added to the scaled source array elements.
</dl><p>
The function <a href="#decl_cvConvertScaleAbs">cvConvertScaleAbs</a> is similar to the previous one, but it stores absolute values
of the conversion results:</p>
<pre>B(I)=abs(A(I)*scale + (shift,shift,...))</pre>
<p>
The function supports only destination arrays of 8u (8-bit unsigned integers) type, for
other types the function can be emulated by combination of <a href="#decl_cvConvertScale">cvConvertScale</a> and <a href="#decl_cvAbsDiffS">cvAbs</a>
functions.</p>


<hr><h3><a name="decl_cvAdd">Add</a></h3>
<p class="Blurb">Computes per-element sum of two arrays</p>
<pre>
void cvAdd( const CvArr* A, const CvArr* B, CvArr* C, const CvArr* mask=0);
</pre><p><dl>

<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvAdd">cvAdd</a> adds one array to another one:</p>
<pre>C(I)=A(I)+B(I) if mask(I)!=0</pre>
<p>All the arrays must have the same type, except the mask, and the same size (or ROI size)</p>


</p><hr><h3><a name="decl_cvAddS">AddS</a></h3>
<p class="Blurb">Computes sum of array and scalar</p>
<pre>
void cvAddS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>S<dd>Added scalar.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvAddS">cvAddS</a> adds scalar <em>S</em> to every element in the source array <em>A</em> and
stores the result in <em>C</em><p>
<pre>C(I)=A(I)+S if mask(I)!=0</pre>
<p>All the arrays must have the same type, except the mask, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvSub">Sub</a></h3>
<p class="Blurb">Computes per-element difference of two arrays</p>
<pre>
void cvSub( const CvArr* A, const CvArr* B, CvArr* C, const CvArr* mask=0);
</pre><p><dl>

<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvSub">cvSub</a> subtracts one array from another one:</p>
<pre>C(I)=A(I)-B(I) if mask(I)!=0</pre>
<p>All the arrays must have the same type, except the mask, and the same size (or ROI size)</p>


</p><hr><h3><a name="decl_cvSubS">SubS</a></h3>
<p class="Blurb">Computes difference of array and scalar</p>
<pre>
void cvSubS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>S<dd>Subed scalar.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvSubS">cvSubS</a> subtracts a scalar from every element of the source array:<p>
<pre>C(I)=A(I)+S if mask(I)!=0</pre>
<p>All the arrays must have the same type, except the mask, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvSubRS">SubRS</a></h3>
<p class="Blurb">Computes difference of scalar and array</p>
<pre>
void cvSubRS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>S<dd>Scalar to subtract from.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvSubRS">cvSubRS</a> subtracts every element of source array from a scalar:</p>
<pre>C(I)=S-A(I) if mask(I)!=0</pre>
<p>All the arrays must have the same type, except the mask, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvMul">Mul</a></h3>
<p class="Blurb">Calculates per-element product of two arrays</p>
<pre>
void cvMul( const CvArr* A, const CvArr* B, CvArr* C, double scale=1 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>scale<dd>Optional scale factor
</dl><p>
The function <a href="#decl_cvMul">cvMul</a> calculates per-element product of two arrays:</p>
<pre>C(I)=scale&bull;A(I)&bull;B(I)</pre>
<p>All the arrays must have the same type, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvDiv">Div</a></h3>
<p class="Blurb">Performs per-element division of two arrays</p>
<pre>
void cvDiv( const CvArr* A, const CvArr* B, CvArr* C, double scale=1 );
</pre><p><dl>
<dt>A<dd>The first source array. If the pointer is NULL, the array is assumed to be all 1's.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>scale<dd>Optional scale factor
</dl><p>
The function <a href="#decl_cvDiv">cvDiv</a> divides one array by another:</p>
<pre>
C(I)=scale&bull;A(I)/B(I), if A!=NULL
C(I)=scale/B(I),      if A=NULL
</pre>
<p>All the arrays must have the same type, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvAnd">And</a></h3>
<p class="Blurb">Calculates per-element bit-wise conjunction of two arrays</p>
<pre>
void cvAnd( const CvArr* A, const CvArr* B, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvAnd">cvAnd</a> calculates per-element bit-wise logical conjunction of two arrays:</p>
<pre>C(I)=A(I)&B(I) if mask(I)!=0</pre>
<p>In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>


<hr><h3><a name="decl_cvAndS">AndS</a></h3>
<p class="Blurb">Calculates per-element bit-wise conjunction of array and scalar</p>
<pre>
void cvAndS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>S<dd>Scalar to use in the operation.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function AndS calculates per-element bit-wise conjunction of array and scalar:</p>
<pre>C(I)=A(I)&S if mask(I)!=0</pre>
<p>Prior to the actual operation the scalar is converted to the same type as
the arrays. In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>

<p>The following sample demonstrates how to calculate absolute value of floating-point array elements
by clearing the most-significant bit:</p>
<pre>
float a[] = { -1, 2, -3, 4, -5, 6, -7, 8, -9 };
CvMat A = cvMat( 3, 3, CV_32F, &a );
int i, abs_mask = 0x7fffffff;
cvAndS( &A, cvRealScalar(*(float*)&abs_mask), &A, 0 );
for( i = 0; i &lt; 9; i++ )
    printf("%.1f ", a[i] );
</pre>
<p>The code should print:</p>
<pre>1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0</pre>


<hr><h3><a name="decl_cvOr">Or</a></h3>
<p class="Blurb">Calculates per-element bit-wise disjunction of two arrays</p>
<pre>
void cvOr( const CvArr* A, const CvArr* B, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvOr">cvOr</a> calculates per-element bit-wise disjunction of two arrays:</p>
<pre>C(I)=A(I)|B(I)</pre>
<p>In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>


<hr><h3><a name="decl_cvOrS">OrS</a></h3>
<p class="Blurb">Calculates per-element bit-wise disjunction of array and scalar</p>
<pre>
void cvOrS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>S<dd>Scalar to use in the operation.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function OrS calculates per-element bit-wise disjunction of array and scalar:</p>
<pre>C(I)=A(I)|S if mask(I)!=0</pre>
<p>Prior to the actual operation the scalar is converted to the same type as
the arrays. In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>


<hr><h3><a name="decl_cvXor">Xor</a></h3>
<p class="Blurb">Performs per-element bit-wise "exclusive or" operation on two arrays</p>
<pre>
void cvXor( const CvArr* A, const CvArr* B, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function <a href="#decl_cvXor">cvXor</a> calculates per-element bit-wise logical conjunction of two arrays:</p>
<pre>C(I)=A(I)^B(I) if mask(I)!=0</pre>
<p>In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>


<hr><h3><a name="decl_cvXorS">XorS</a></h3>
<p class="Blurb">Performs per-element bit-wise "exclusive or" operation on array and scalar</p>
<pre>
void cvXorS( const CvArr* A, CvScalar S, CvArr* C, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>S<dd>Scalar to use in the operation.
<dt>C<dd>The destination array.
<dt>mask<dd>Operation mask, 8-bit single channel array; specifies elements of
destination array to be changed.
</dl><p>
The function XorS calculates per-element bit-wise conjunction of array and scalar:</p>
<pre>C(I)=A(I)^S if mask(I)!=0</pre>
<p>Prior to the actual operation the scalar is converted to the same type as
the arrays. In the case of floating-point arrays their bit representations are used for the
operation. All the arrays must have the same type, except the mask, and the same size</p>

<p>The following sample demonstrates how to conjugate complex vector
by switching the most-significant bit of imaging part:</p>
<pre>
float a[] = { 1, 0, 0, 1, -1, 0, 0, -1 }; /* 1, j, -1, -j */
CvMat A = cvMat( 4, 1, CV_32FC2, &a );
int i, neg_mask = 0x80000000;
cvXorS( &A, cvScalar( 0, *(float*)&neg_mask, 0, 0 ), &A, 0 );
for( i = 0; i &lt; 4; i++ )
    printf("(%.1f, %.1f) ", a[i*2], a[i*2+1] );
</pre>
<p>The code should print:</p>
<pre>(1.0,0.0) (0.0,-1.0) (-1.0,0.0) (0.0,1.0)</pre>


<hr><h3><a name="decl_cvNot">Not</a></h3>
<p class="Blurb">Performs per-element bit-wise inversion of array elements</p>
<pre>
void cvNot( const CvArr* A, CvArr* C );
</pre><p><dl>
<dt>A<dd>The source array.
<dt>C<dd>The destination array.
</dl><p>
The function Not inverses every bit of every array element:</p>
<pre>C(I)=~A(I)</pre>


<hr><h3><a name="decl_cvCmp">Cmp</a></h3>
<p class="Blurb">Performs per-element comparison of two arrays</p>
<pre>
void cvCmp( const CvArr* A, const CvArr* B, CvArr* C, int cmp_op );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array. Both source array must have a single channel.
<dt>C<dd>The destination array, must have 8u or 8s type.
<dt>cmp_op<dd>The flag specifying the relation between the elements to be checked:<br>
              CV_CMP_EQ - A(I) "equal to" B(I)<br>
              CV_CMP_GT - A(I) "greater than" B(I)<br>
              CV_CMP_GE - A(I) "greater or equal" B(I)<br>
              CV_CMP_LT - A(I) "less than" B(I)<br>
              CV_CMP_GE - A(I) "less or equal" B(I)<br>
              CV_CMP_NE - A(I) "not equal to" B(I)<br>
</dl><p>
The function <a href="#decl_cvCmp">cvCmp</a> compares the corresponding elements of two arrays and
fills the destination mask array:</p>
<pre>
C(I)=A(I) op B(I),
</pre>
<p>where <em>op</em> is '=', '&gt;', '&gt;=', '&lt;', '&lt;=' or '!='.</p>
<p><em>C(I)</em> is set to 0xff (all '1'-bits) if the particular relation between the elements
is true and 0 otherwise.
All the arrays must have the same type, except the destination, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvCmpS">CmpS</a></h3>
<p class="Blurb">Performs per-element comparison of array and scalar</p>
<pre>
void cvCmpS( const CvArr* A, double S, CvArr* C, int cmp_op );
</pre><p><dl>
<dt>A<dd>The source array, must have a single channel.
<dt>C<dd>The destination array, must have 8u or 8s type.
<dt>cmp_op<dd>The flag specifying the relation between the elements to be checked:<br>
              CV_CMP_EQ - A(I) "equal to" S<br>
              CV_CMP_GT - A(I) "greater than" S<br>
              CV_CMP_GE - A(I) "greater or equal" S<br>
              CV_CMP_LT - A(I) "less than" S<br>
              CV_CMP_GE - A(I) "less or equal" S<br>
              CV_CMP_NE - A(I) "not equal" S<br>
</dl><p>
The function <a href="#decl_cvCmpS">cvCmpS</a> compares the corresponding elements of array and scalar
and fills the destination mask array:</p>
<pre>
C(I)=A(I) op S,
</pre>
<p>where <em>op</em> is '=', '&gt;', '&gt;=', '&lt;', '&lt;=' or '!='.</p>
<p><em>C(I)</em> is set to 0xff (all '1'-bits) if the particular relation between the elements
is true and 0 otherwise.
All the arrays must have the same size (or ROI size)</p>



<hr><h3><a name="decl_cvInRange">InRange</a></h3>
<p class="Blurb">Checks that array elements lie between elements of two other arrays</p>
<pre>
void cvInRange( const CvArr* A, const CvArr* L, const CvArr* U, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>L<dd>The inclusive lower boundary array.
<dt>U<dd>The exclusive upper boundary array.
<dt>C<dd>The destination array, must have 8u or 8s type.
</dl><p>
The function <a href="#decl_cvInRange">cvInRange</a> does the range check for every element of the input array:</p>
<pre>
C(I)=L(I)<sub>0</sub> &lt;= A(I)<sub>0</sub> &lt; U(I)<sub>0</sub>
</pre>
<p>for single-channel arrays,</p>
<pre>
C(I)=L(I)<sub>0</sub> &lt;= A(I)<sub>0</sub> &lt; U(I)<sub>0</sub> &&
     L(I)<sub>1</sub> &lt;= A(I)<sub>1</sub> &lt; U(I)<sub>1</sub>
</pre><p>for two-channel arrays etc.</p>
<p><em>C(I)</em> is set to 0xff (all '1'-bits) if A(I) is within the range and 0 otherwise.
All the arrays must have the same type, except the destination, and the same size (or ROI size)</p>


<hr><h3><a name="decl_cvInRangeS">InRangeS</a></h3>
<p class="Blurb">Checks that array elements lie between two scalars</p>
<pre>
void cvInRangeS( const CvArr* A, CvScalar SL, CvScalar SU, CvArr* D );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>SL<dd>The inclusive lower boundary.
<dt>SU<dd>The exclusive upper boundary.
<dt>C<dd>The destination array, must have 8u or 8s type.
</dl><p>
The function <a href="#decl_cvInRangeS">cvInRangeS</a> does the range check for every element of the input array:</p>
<pre>
C(I)=SL<sub>0</sub> &lt;= A(I)<sub>0</sub> &lt; SU<sub>0</sub>
</pre>
<p>for a single-channel array,</p>
<pre>
C(I)=SL<sub>0</sub> &lt;= A(I)<sub>0</sub> &lt; SU<sub>0</sub> &&
     SL<sub>1</sub> &lt;= A(I)<sub>1</sub> &lt; SU<sub>1</sub>
</pre><p>for a two-channel array etc.</p>
<p>
<p><em>C(I)</em> is set to 0xff (all '1'-bits) if A(I) is within the range and 0 otherwise.
All the arrays must have the same size (or ROI size)</p>


<hr><h3><a name="decl_cvMax">Max</a></h3>
<p class="Blurb">Finds per-element maximum of two arrays</p>
<pre>
void cvMax( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
</dl><p>
The function <a href="#decl_cvMax">cvMax</a> calculates per-element maximum of two arrays:</p>
<pre>C(I)=max(A(I), B(I))</pre>
<p>All the arrays must have a single channel, the same data type
and the same size (or ROI size).</p>


<hr><h3><a name="decl_cvMaxS">MaxS</a></h3>
<p class="Blurb">Finds per-element maximum of array and scalar</p>
<pre>
void cvMaxS( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
</dl><p>
The function <a href="#decl_cvMaxS">cvMaxS</a> calculates per-element maximum of array and scalar:</p>
<pre>C(I)=max(A(I), S)</pre>
<p>All the arrays must have a single channel, the same data type
and the same size (or ROI size).</p>


<hr><h3><a name="decl_cvMin">Min</a></h3>
<p class="Blurb">Finds per-element minimum of two arrays</p>
<pre>
void cvMin( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
</dl><p>
The function <a href="#decl_cvMin">cvMin</a> calculates per-element minimum of two arrays:</p>
<pre>
C(I)=min(A(I),B(I))
</pre>
<p>All the arrays must have a single channel, the same data type
and the same size (or ROI size).</p>



<hr><h3><a name="decl_cvMinS">MinS</a></h3>
<p class="Blurb">Finds per-element minimum of array and scalar</p>
<pre>
void cvMinS( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
</dl><p>
The function <a href="#decl_cvMinS">cvMinS</a> calculates minimum of array and scalar:</p>
<pre>C(I)=min(A(I), S)</pre>
<p>All the arrays must have a single channel, the same data type
and the same size (or ROI size).</p>


<hr><h3><a name="decl_cvAbsDiff">AbsDiff</a></h3>
<p class="Blurb">Calculates absolute difference between two arrays</p>
<pre>
void cvAbsDiff( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array.
</dl><p>
The function <a href="#decl_cvAbsDiff">cvAbsDiff</a> calculates absolute difference between two arrays.</p>
<pre>C(I)<sub>c</sub> = abs(A(I)<sub>c</sub> - B(I)<sub>c</sub>).</pre>
<p>All the arrays must have the same data type and the same size (or ROI size).</p>


<hr><h3><a name="decl_cvAbsDiffS">AbsDiffS</a></h3>
<p class="Blurb">Calculates absolute difference between array and scalar</p>
<pre>
void cvAbsDiffS( const CvArr* A, CvArr* C, CvScalar S );
#define cvAbs(A, C) cvAbsDiffS(A, C, cvScalarAll(0))
</pre><p><dl>
<dt>A<dd>The source array.
<dt>C<dd>The destination array.
<dt>S<dd>The scalar.
</dl><p>
The function <a href="#decl_cvAbsDiffS">cvAbsDiffS</a> calculates absolute difference between array and scalar.</p>
<pre>C(I)<sub>c</sub> = abs(A(I)<sub>c</sub> - S<sub>c</sub>).</pre>
<p>All the arrays must have the same data type and the same size (or ROI size).</p>


<hr><h2><a name="ch1_array_stat">Array statistics</a></h2>

<hr><h3><a name="decl_cvCountNonZero">CountNonZero</a></h3>
<p class="Blurb">Counts non-zero array elements</p>
<pre>
int cvCountNonZero( const CvArr* A );
</pre><p><dl>
<dt>A<dd>The array, must be single-channel array or multi-channel image with COI set.
</dl><p>
The function <a href="#decl_cvCountNonZero">cvCountNonZero</a> returns the number of non-zero elements in A:</p>
<pre>
result = sum<sub>I</sub> A(I)!=0
</pre>
In case of <em>IplImage</em> both ROI and COI are supported.</p>


<hr><h3><a name="decl_cvSum">Sum</a></h3>
<p class="Blurb">Summarizes array elements</p>
<pre>
CvScalar cvSum( const CvArr* A );
</pre><p><dl>
<dt>A<dd>The array.
</dl><p>
The function <a href="#decl_cvSum">cvSum</a> calculates sum <em>S</em> of array elements, independently for each channel:</p>
<pre>
S<sub>c</sub> = sum<sub>I</sub> A(I)<sub>c</sub>
</pre>
If the array is <em>IplImage</em> and COI is set, the function processes the selected channel only
and stores the sum to the first scalar component (S<sub>0</sub>).</p>


<hr><h3><a name="decl_cvAvg">Avg</a></h3>
<p class="Blurb">Calculates average (mean) of array elements</p>
<pre>
CvScalar cvAvg( const CvArr* A, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The array.
<dt>mask<dd>The optional operation mask.
</dl><p>
The function <a href="#decl_cvAvg">cvAvg</a> calculates the average value <em>M</em> of array elements, independently for each channel:</p>
<pre>
N = sum<sub>I</sub> mask(I)!=0

M<sub>c</sub> = 1/N &bull; sum<sub>I</sub> A(I)<sub>c</sub>
</pre>
If the array is <em>IplImage</em> and COI is set, the function processes the selected channel only
and stores the average to the first scalar component (S<sub>0</sub>).</p>


<hr><h3><a name="decl_cvAvgSdv">AvgSdv</a></h3>
<p class="Blurb">Calculates average (mean) of array elements</p>
<pre>
void cvAvgSdv( const CvArr* A, CvScalar* _M, CvScalar* _S, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The array.
<dt>_M<dd>Pointer to the mean value, may be NULL if it is not needed.
<dt>_S<dd>Pointer to the standard deviation.
<dt>mask<dd>The optional operation mask.
</dl><p>
The function <a href="#decl_cvAvgSdv">cvAvgSdv</a> calculates the average value <em>M=*_M</em> and
standard deviation <em>S=*_S</em> of array elements, independently for each channel:</p>
<pre>
N = sum<sub>I</sub> mask(I)!=0

M<sub>c</sub> = 1/N &bull; sum<sub>I</sub> A(I)<sub>c</sub>

S<sub>c</sub> = sqrt(1/N &bull; sum<sub>I</sub> (A(I)<sub>c</sub> - M<sub>c</sub>)<sup>2</sup>)
</pre>
If the array is <em>IplImage</em> and COI is set, the function processes the selected channel only
and stores the average and standard deviation to the first compoenents of output scalars (M<sub>0</sub>
and S<sub>0</sub>).</p>



<hr><h3><a name="decl_cvMinMaxLoc">MinMaxLoc</a></h3>
<p class="Blurb">Finds global minimum and maximum in array or subarray</p>
<pre>
void cvMinMaxLoc( const CvArr* A, double* minVal, double* maxVal,
                  CvPoint* minLoc, CvPoint* maxLoc, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The source array, single-channel or multi-channel with COI set.
<dt>minVal<dd>Pointer to returned minimum value.
<dt>maxVal<dd>Pointer to returned maximum value.
<dt>minLoc<dd>Pointer to returned minimum location.
<dt>maxLoc<dd>Pointer to returned maximum location.
<dt>mask<dd>The optional mask that is used to select a subarray.
</dl><p>
The function <em>MinMaxLoc</em> finds minimum and maximum element values and their
positions. The extremums are searched over the whole array, selected <em>ROI</em> (in case
of <em>IplImage</em>) or, if <em>mask</em> is not <em>NULL</em>, in the specified array region.
If the array has more than one channel, it must be <em>IplImage</em> with <em>COI</em> set.
In case if multi-dimensional arrays <em>minLoc->x</em> and <em>maxLoc->x</em> will contain raw (linear)
positions of the extremums.</p>


<hr><h3><a name="decl_cvNorm">Norm</a></h3>
<p class="Blurb">Calculates absolute array norm, absolute difference norm or relative difference norm</p>
<pre>
double cvNorm( const CvArr* A, const CvArr* B, int normType, const CvArr* mask=0 );
</pre><p><dl>
<dt>A<dd>The first source image.
<dt>B<dd>The second source image. If it is NULL, the absolute norm of <em>A</em> is calculated, otherwise
         absolute or relative norm of <em>A</em>-<em>B</em> is calculated.
<dt>normType<dd>Type of norm, see the discussion.
<dt>mask<dd>The optional operation mask.
</dl><p>
The function <a href="#decl_cvNorm">cvNorm</a> calculates the absolute norm of <em>A</em> if <em>B</em> is NULL:</p>
<pre>
norm = ||A||<sub>C</sub> = max<sub>I</sub> abs(A(I)),  if <em>normType</em> = CV_C

norm = ||A||<sub>L1</sub> = sum<sub>I</sub> abs(A(I)),  if <em>normType</em> = CV_L1

norm = ||A||<sub>L2</sub> = sqrt( sum<sub>I</sub> A(I)<sup>2</sup>),  if <em>normType</em> = CV_L2

</pre>
<p>And the function calculates absolute or relative difference norm if <em>B</em> is not NULL:</p>
<pre>
norm = ||A-B||<sub>C</sub> = max<sub>I</sub> abs(A(I)-B(I)),  if <em>normType</em> = CV_C

norm = ||A-B||<sub>L1</sub> = sum<sub>I</sub> abs(A(I)-B(I)),  if <em>normType</em> = CV_L1

norm = ||A-B||<sub>L2</sub> = sqrt( sum<sub>I</sub> (A(I)-B(I))<sup>2</sup> ),  if <em>normType</em> = CV_L2

or

norm = ||A-B||<sub>C</sub>/||B||<sub>C</sub>, if <em>normType</em> = CV_RELATIVE_C

norm = ||A-B||<sub>L1</sub>/||B||<sub>L1</sub>, if <em>normType</em> = CV_RELATIVE_L1

norm = ||A-B||<sub>L2</sub>/||B||<sub>L2</sub>, if <em>normType</em> = CV_RELATIVE_L2

</pre>
<p>
The function<em> Norm</em> returns the calculated norm.
The multiple-channel array are treated as single-channel, that is results for all channels
are combined.
</p>


<!-- *****************************************************************************************
     *****************************************************************************************
     ***************************************************************************************** -->

<hr><h2><a name="ch1_matrix_op">Matrix Operations, Linear Algebra and Math Functions</a></h2>


<hr><h3><a name="decl_cvSetIdentity">SetIdentity</a></h3>
<p class="Blurb">Initializes scaled identity matrix</p>
<pre>
void cvSetIdenity( CvArr* A, CvScalar S );
</pre><p><dl>
<dt>A<dd>The matrix to initialize (not necesserily square).
<dt>S<dd>The value to assign to the diagonal elements.
</dl><p>
The function <a href="#decl_cvSetIdentity">cvSetIdentity</a> initializes scaled identity matrix:</p>
<pre>
A(i,j)=S if i=j,
       0 otherwise
</pre>


<hr><h3><a name="decl_cvDotProduct">DotProduct</a></h3>
<p class="Blurb">Calculates dot product of two arrays in Euclidian metrics</p>
<pre>
double cvDotProduct (const CvArr* A, const CvArr* B );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
</dl><p>
The function <a href="#decl_cvDotProduct">cvDotProduct</a> calculates and returns the Euclidean dot product of two
arrays.</p>
<pre>A&bull;B = sum<sub>I</sub>(A(I)*B(I))
</pre>
<p>In case of multiple channel arrays the results for all channels are
accumulated. In particular, it gives a correct result for complex matrices.
The function can process multi-dimensional arrays row by row.</p>


<hr><h3><a name="decl_cvCrossProduct">CrossProduct</a></h3>
<p class="Blurb">Calculates cross product of two 3D vectors</p>
<pre>
void cvCrossProduct( const CvArr* A, const CvArr* B, CvArr* C );
</pre><p><dl>
<dt>A<dd>The first source vector.
<dt>B<dd>The second source vector.
<dt>C<dd>The destination vector.
</dl><p>
The function <a href="#decl_cvCrossProduct">cvCrossProduct</a> calculates the cross product of two 3D vectors:</p>
<pre>C = A&times;B, (C<sub>1</sub> = A<sub>2</sub>B<sub>3</sub> - A<sub>3</sub>B<sub>2</sub> , C<sub>2</sub> = A<sub>3</sub>B<sub>1</sub> - A<sub>1</sub>B<sub>3</sub> , C<sub>3</sub> = A<sub>1</sub>B<sub>2</sub> - A<sub>2</sub>B<sub>1</sub>).</pre>


<hr><h3><a name="decl_cvScaleAdd">ScaleAdd</a></h3>
<p class="Blurb">Calculates sum of scaled array and another array</p>
<pre>
void cvScaleAdd( const CvArr* A, CvScalar S, const CvArr* B, CvArr* C );
#define cvMulAddS cvScaleAdd
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>S<dd>Scale factor for the first array.
<dt>B<dd>The second source array.
<dt>C<dd>The destination array
</dl><p>
The function <a href="#decl_cvScaleAdd">cvScaleAdd</a> calculates sum of scaled array and another array:</p>
<pre>C(I)=A(I)*S + B(I)</pre>
<p>All array parameters should be of the same size and the same size</p>


<hr><h3><a name="decl_cvMatMulAdd">MatMulAdd</a></h3>
<p class="Blurb">Calculates shifted matrix product</p>
<pre>
void cvMatMulAdd( const CvArr* A, const CvArr* B, const CvArr* C, CvArr* D );
#define cvMatMul(A, B, D) cvMatMulAdd(A, B, 0, D)
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The third source array (shift). Can be NULL, if there is no shift.
<dt>D<dd>The destination array.
</dl><p>
The function <a href="#decl_cvMatMulAdd">cvMatMulAdd</a> calculates matrix product of two matrices and adds the third matrix
to the product:</p>
<pre>D = A*B + C   or  D(i,j)=sum<sub>k</sub>(A(i,k)*B(k,j)) + C(i,j)
</pre><p>
All the matrices should be of the same type and the coordinated sizes. Only
real or complex floating-point matrices are supported</p>


<hr><h3><a name="decl_cvGEMM">GEMM</a></h3>
<p class="Blurb">Performs generalized matrix multiplication</p>
<pre>
void  cvGEMM( const CvArr* A, const CvArr* B, double alpha,
              const CvArr* C, double beta, CvArr* D, int tABC=0 );
#define cvMatMulAddEx cvGEMM
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>B<dd>The second source array.
<dt>C<dd>The third source array (shift). Can be NULL, if there is no shift.
<dt>D<dd>The destination array.
<dt>tABC<dd>The operation flags that can be 0 or combination of the following:<br>
            CV_GEMM_A_T - transpose A<br>
            CV_GEMM_B_T - transpose B<br>
            CV_GEMM_C_T - transpose B<br>
            for example, CV_GEMM_A_T+CV_GEMM_C_T corresponds to
            <pre>alpha*A<sup>T</sup>*B + beta*C<sup>T</sup></pre>
</dl><p>
The function <a href="#decl_cvGEMM">cvGEMM</a> performs generalized matrix multiplication:</p>
<pre>D = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X<sup>T</sup></pre>
<p>
All the matrices should be of the same type and the coordinated sizes. Only
real or complex floating-point matrices are supported</p>


<hr><h3><a name="decl_cvMatMulAddS">MatMulAddS</a></h3>
<p class="Blurb">Performs matrix transform on every element of array</p>
<pre>
void cvMatMulAddS( const CvArr* A, CvArr* C, const CvArr* M, const CvArr* V=0 );
</pre><p><dl>
<dt>A<dd>The first source array.
<dt>C<dd>The destination array.
<dt>M<dd>Transformation matrix.
<dt>V<dd>Optional shift.
</dl><p>
The function <a href="#decl_cvMatMulAddS">cvMatMulAddS</a> performs matrix transform on every element of array <em>A</em>
and stores the result in <em>C</em>:</p>
<pre>C(i,j)=M*A(i,j) + V   or   C(i,j)(k)=sum<sub>l</sub>(M(k,l)*A(i,j)(l)) + V(k)</pre>
<p>That is every element of <em>N</em>-channel array <em>A</em> is considered as <em>N</em>-element vector, which is
transformed using matrix <em>N</em>&times;<em>N</em> matrix <em>M</em> and shift vector <em>V</em>.
There is an option to code <em>V</em> into <em>A</em>. In this case <em>A</em> should be
<em>N</em>&times;<em>N+1</em> matrix and the right-most column is used as the shift vector.</p>
<p>
Both source and destination arrays should be of the same size or selected ROI
size and of the same type. <em>M</em> and <em>V</em> should be real floating-point matrices.
The function can be used for geometrical transforms of point sets and linear
color transformations.</p>

<hr><h3><a name="decl_cvMulTransposed">MulTransposed</a></h3>
<p class="Blurb">Calculates product of array and transposed array</p>
<pre>
void cvMulTransposed( const CvArr* A, CvArr* C, int order );
</pre><p><dl>
<dt>A<dd>The source matrix.
<dt>C<dd>The destination matrix.
<dt>order<dd>Order of multipliers.
</dl><p>
The function <a href="#decl_cvMulTransposed">cvMulTransposed</a> calculates the product of A and its transposition.</p>
<p>The function evaluates</p>
<pre>C=A*A<sup>T</sup></pre>
<p>if order=0, and
<pre>C=A<sup>T</sup>*A</pre>
<p>otherwise</p>


<hr><h3><a name="decl_cvTrace">Trace</a></h3>
<p class="Blurb">Returns trace of matrix</p>
<pre>
CvScalar cvTrace( const CvArr* A );
</pre><p><dl>
<dt>A<dd>The source matrix.
</dl><p>
The function <a href="#decl_cvTrace">cvTrace</a> returns sum of diagonal elements of the matrix <em>A</em>.
<pre>
tr(A)=sum<sub>i</sub>A(i,i)
</pre>


<hr><h3><a name="decl_cvTranspose">Transpose</a></h3>
<p class="Blurb">Transposes matrix</p>
<pre>
void cvTranspose( const CvArr* A, CvArr* B );
#define cvT cvTranspose
</pre><p><dl>
<dt>A<dd>The source matrix.
<dt>B<dd>The destination matrix.
</dl><p>
The function <a href="#decl_cvTranspose">cvTranspose</a> transposes matrix <em>A</em>:</p>
<pre>
B(i,j)=A(j,i)
</pre>
<p>Note that no complex conjugation is done in case of complex matrix. Conjugation
should be done separately: look at the sample code in <a href="#decl_cvXorS">cvXorS</a> for example</p>


<hr><h3><a name="decl_cvDet">Det</a></h3>
<p class="Blurb">Returns determinant of matrix</p>
<pre>
CvScalar cvDet( const CvArr* A );
</pre><p><dl>
<dt>A<dd>The source matrix.
</dl><p>
The function <a href="#decl_cvDet">cvDet</a> returns determinant of the square matrix <em>A</em>.
The direct method is used for small matrices and Gaussian elimination is used for larger matrices</p>


<hr><h3><a name="decl_cvInvert">Invert</a></h3>
<p class="Blurb">Finds inverse or pseudo-inverse of matrix</p>
<pre>
double cvInvert( const CvArr* A, CvArr* B, int method );
#define cvInv cvInvert
</pre><p><dl>
<dt>A<dd>The source matrix.
<dt>B<dd>The destination matrix.
<dt>method<dd>Inversion method:<br>
              CV_LU - Gaussian elimination with optimal pivot element chose
              CV_SVD - Singular decomposition method
</dl><p>
The function <a href="#decl_cvInvert">cvInvert</a> inverts matrix <em>A</em> and stores the result in <em>B</em></p>
<p>In case of <em>LU</em> method the function returns <em>A</em> determinant (A must be square).
If it is 0, the matrix is not inverted and <em>B</em> is filled with zeros.</p>
<p>In case of <em>SVD</em> method the function returns the inversed condition number of <em>A</em>
(ratio of the smallest singular value to the largest singular value) and 0 if <em>A</em> is all zeros.
This method calculates a pseudo-inverse matrix if <em>A</em> is singular</p>



<hr><h3><a name="decl_cvSolve">Solve</a></h3>
<p class="Blurb">Solves linear system or least-squares problem</p>
<pre>
int cvSolve( const CvArr* A, const CvArr* B, CvArr* X, int method );
#define cvInv cvSolve
</pre><p><dl>
<dt>A<dd>The source matrix.
<dt>B<dd>The right-hand part of the linear system.
<dt>method<dd>The solution (matrix inversion) method:<br>
              CV_LU - Gaussian elimination with optimal pivot element chose
              CV_SVD - Singular decomposition method
</dl><p>
The function <a href="#decl_cvSolve">cvSolve</a> solves linear system or least-squares problem:</p>
<pre>
X<sup>*</sup> = arg min<sub>X</sub>||A*X-B||
</pre>
<p>If <em>CV_LU</em> method is used, the function returns 1 if <em>A</em> is non-singular and
0 otherwise, in the latter case <em>X</em> is not valid</p>


<hr><h3><a name="decl_cvSVD">SVD</a></h3>
<p class="Blurb">Performs singular value decomposition of real floating-point matrix</p>
<pre>
void cvSVD( CvArr* A, CvArr* W, CvArr* U=0, CvArr* V=0, int flags=0 );
</pre><p><dl>

<dt>A<dd>Source <em>M</em>&times;<em>N</em> matrix.
<dt>W<dd>Resulting singular value matrix (<em>M</em>&times;<em>N</em> or <em>N</em>&times;<em>N</em>) or
         vector (<em>N</em>&times;<em>1</em>).
<dt>U<dd>Optional left orthogonal matrix (<em>M</em>&times;<em>M</em> or <em>M</em>&times;<em>N</em>).
         If CV_SVD_U_T is specified, the number of rows and columns in the sentence above should be swapped.
<dt>V<dd>Optional right orthogonal matrix (<em>N</em>&times;<em>N</em>)
<dt>flags<dd>Operation flags; can be 0 or combination of the following:
<ul>
<li>  <em>CV_SVD_MODIFY_A</em> enables modification of matrix <em>A</em> during the operation. It
  speeds up the processing.
<li>  <em>CV_SVD_U_T</em> means that the tranposed matrix <em>U</em> is returned.
      Specifying the flag speeds up the processing.
<li>  <em>CV_SVD_V_T</em> means that the tranposed matrix <em>V</em> is returned.
      Specifying the flag speeds up the processing.
</ul>
</dl><p>
The function <a href="#decl_cvSVD">cvSVD</a> decomposes matrix <em>A</em> into a product of a diagonal matrix and two
orthogonal matrices:</p>
<pre>
A=U*W*V<sup>T</sup>
</pre>
<p>Where <em>W</em> is diagonal matrix of singular values that can be coded as a 1D
vector of singular values and <em>U</em> and <em>V</em>. All the singular values are non-negative and sorted (together with <em>U</em> and
and <em>V</em> columns) in descenting order.</p>
<p>SVD algorithm is numerically robust and its typical applications include:
<ul>
<li>accurate eigenvalue problem solution when matrix <em>A</em> is square, symmetric and positively
  defined matrix, for example, when it is a covariation matrix.
  <em>W</em> in this case will be a vector of eigen values, and <em>U</em>=<em>V</em> is matrix of
  eigen vectors (thus, only one of <em>U</em> or <em>V</em> needs to be calculated if
  the eigen vectors are required)</li>
<li>accurate solution of poor-conditioned linear systems</li>
<li>least-squares solution of overdetermined linear systems. This and previous is done by <a href="#decl_cvSolve">cvSolve</a>
    function with <em>CV_SVD</em> method</li>
<li>accurate calculation of different matrix characteristics such as rank
   (number of non-zero singular values),
  condition number (ratio of the largest singular value to the smallest one),
  determinant (absolute value of determinant is equal to the product of singular values).
  All the things listed in this item do not require calculation of <em>U</em>
  and <em>V</em> matrices.</li>
</ul></p>



<hr><h3><a name="decl_cvSVBkSb">SVBkSb</a></h3>
<p class="Blurb">Performs singular value back substitution</p>
<pre>
void  cvSVBkSb( const CvArr* W, const CvArr* U, const CvArr* V,
                const CvArr* B, CvArr* X, int flags );
</pre><p><dl>

<dt>W<dd>Matrix or vector of singular values.
<dt>U<dd>Left orthogonal matrix (tranposed, perhaps)
<dt>V<dd>Right orthogonal matrix (tranposed, perhaps)
<dt>B<dd>The matrix to multiply the pseudo-inverse of the original matrix <em>A</em> by.
         This is the optional parameter. If it is omitted then it is assumed to be
         an identity matrix of an appropriate size (So <em>X</em> will be the reconstructed
         pseudo-inverse of <em>A</em>).
<dt>X<dd>The destination matrix: result of back substitution.
<dt>flags<dd>Operation flags, should match exactly to the <em>flags</em> passed to <a href="#decl_cvSVD">cvSVD</a>.
</dl><p>
The function <a href="#decl_cvSVBkSb">cvSVBkSb</a> calculates back substitution for decomposed matrix <em>A</em> (see
<a href="#decl_cvSVD">cvSVD</a> description) and matrix <em>B</em>:</p>
<pre>
X=V*W<sup>-1</sup>*U<sup>T</sup>*B
</pre>
<p>Where</p>
<pre>
W<sup>-1</sup>(i,j)=1/W(i,j) if W(i,j) > epsilon,
                    0        otherwise
</pre>
<p>And <em>epsilon</em> is a small number - &asymp;10<sup>-6</sup> or &asymp;10<sup>-15</sup> depending
on the matrices element type.
</p>
This function together with <a href="#decl_cvSVD">cvSVD</a> is used inside <a href="#decl_cvInvert">cvInvert</a> and <a href="#decl_cvSolve">cvSolve</a>,
and the possible reason to use these (svd & bksb) "low-level" function is to avoid
temporary matrices allocation inside the high-level counterparts (inv & solve).</p>


<hr><h3><a name="decl_cvEigenVV">EigenVV</a></h3>
<p class="Blurb">Computes eigenvalues and eigenvectors of symmetric matrix</p>
<pre>
void cvEigenVV( CvArr* A, CvArr* evects, CvArr* evals, double eps );
</pre><p><dl>
<dt>A<dd>The source symmetric square matrix. It is modified during the processing.
<dt>evects<dd>The output matrix of eigenvectors, stored as a subsequent rows.
<dt>evals<dd>The output vector of eigenvalues, stored in the descenting order (order of
eigenvalues and eigenvectors is syncronized, of course).
<dt>eps<dd>Accuracy of diagonalization (typically, DBL_EPSILON=&asymp;10<sup>-15</sup> is enough).
</dl><p>
The function <a href="#decl_cvEigenVV">cvEigenVV</a> computes the eigenvalues and eigenvectors of the matrix <em>A</em>:</p>
<pre>A*evects(i,:)' = evals(i)*evects(i,:)' (in MATLAB notation)</pre>
<p>The contents of matrix <em>A</em> is destroyed by the function.</p>
<p>Currently the function is slower than <a href="#decl_cvSVD">cvSVD</a> yet less accurate,
so if <em>A</em> is known to be positively-defined (for example, it is a covariation matrix),
it is recommended to use <a href="#decl_cvSVD">cvSVD</a> to find eigenvalues and eigenvectors of <em>A</em>,
especially if eigenvectors are not required.</p>


<hr><h3><a name="decl_cvPerspectiveTransform">PerspectiveTransform</a></h3>
<p class="Blurb">Performs perspective matrix transform on 3D vector array</p>
<pre>
void cvPerspectiveTransform( const CvArr* A, CvArr* B, const CvArr* M );
</pre><p><dl>
<dt>A<dd>The source three-channel floating-point array.
<dt>B<dd>The destination three-channel floating-point array.
<dt>M<dd>4 &times; 4 transformation matrix.
</dl><p>
The function <a href="#decl_cvPerspectiveTransform">cvPerspectiveTransform</a> transforms every element of <em>A</em>
considering it a 3D vector as:</p>
<pre>
(x, y, z) -> (x'/w, y'/w, z'/w),

where
(x', y', z', w') = M*(x, y, z, 1)

and w = 1/w' if w'!=0,
          1  otherwise
</pre>


<hr><h3><a name="decl_cvCalcCovarMatrix">CalcCovarMatrix</a></h3>
<p class="Blurb">Calculates covariation matrix out of the set of arrays</p>
<pre>
void cvCalcCovarMatrix( CvArr** Vs, CvArr* M, CvArr* A );
</pre><p><dl>
<dt>Vs<dd>The set of input arrays. All the arrays must have the same type and the same size.
<dt>M<dd>The output covariation matrix that should be floating-point and square.
         Number of arrays is implicitly assumed to be equal to number of the matrix rows/columns.
<dt>A<dd>The output array that is set to the average of the input arrays.
</dl><p>
The function <a href="#decl_cvCalcCovarMatrix">cvCalcCovarMatrix</a> calculates the covariation matrix and average array out of
the set of input arrays:</p>
<pre>
A(I)=sum<sub>k</sub>Vs<sup>(k)</sup>(I)

M(i,j)=(Vs<sup>(i)</sup>-A)&bull;(Vs<sup>(j)</sup>-A)
</pre>
<p>Where the upper index in parentheses means the particular array from the set and
"&bull;" means dot product. The covariation matrix may be used then (after inversion) in <a href="#decl_cvMahalonobis">cvMahalonobis</a> function to
measure a distance between vectors, to find eigen objects via <a href="#decl_cvSVD">cvSVD</a> etc.</p>


<hr><h3><a name="decl_cvMahalonobis">Mahalonobis</a></h3>
<p class="Blurb">Calculates Mahalonobis distance between vectors</p>
<pre>
double cvMahalonobis( const CvArr* A, const CvArr* B, CvArr* T );
</pre><p><dl>
<dt>A<dd>The first 1D source vector.
<dt>B<dd>The second 1D source vector.
<dt>T<dd>The inverse covariation matrix.
</dl><p>
The function <a href="#decl_cvMahalonobis">cvMahalonobis</a> calculates the weighted distance between two vectors
and returns it:</p>
<pre>
d(A,B)=sqrt( sum<sub>i,j</sub> {T(i,j)*(A(i)-B(i))*(A(j)-B(j))} )
</pre>
<p>The covariation matrix may be calculated using <a href="#decl_cvCalcCovarMatrix">cvCalcCovarMatrix</a> function and further
inverted using <a href="#decl_cvInvert">cvInvert</a> function (CV_SVD method is the preffered one, because the matrix
might be singular).</p>


<hr><h3><a name="decl_cvCartToPolar">CartToPolar</a></h3>
<p class="Blurb">Calculates magnitude and/or angle of 2d vectors</p>
<pre>
void cvCartToPolar( const CvArr* X, const CvArr* Y, CvArr* M, CvArr* A,
                    int angle_in_degrees=0 );
</pre><p><dl>
<dt>X<dd>The array of x-coordinates
<dt>Y<dd>The array of y-coordinates
<dt>M<dd>The destination array of magnitudes, may be set to NULL if it is not needed
<dt>A<dd>The destination array of angles, may be set to NULL if it is not needed.
        The angles are measured in radians (0..2&pi;) or in degrees (0..360&deg;).
<dt>angle_in_degrees<dd>The flag indicating whether the angles are measured in radians,
                        which is default mode, or in degrees.
</dl><p>
The function <a href="#decl_cvCartToPolar">cvCartToPolar</a> calculates either magnitude, angle,
or both of every vector <em>(X(I),Y(I))</em>:</p>
<pre>
M(I)=sqrt( X(I)<sup>2</sup>+Y(I)<sup>2</sup> ),
A(I)=atan( Y(I)/X(I) )
</pre>
<p>The angles are calculated with &asymp;0.1&deg; accuracy. For (0,0) point the angle
is set to 0.</p>


<hr><h3><a name="decl_cvPolarToCart">PolarToCart</a></h3>
<p class="Blurb">Calculates cartesian coordinates of 2d vectors represented in polar form</p>
<pre>
void cvPolarToCart( const CvArr* M, const CvArr* A, CvArr* X, CvArr* Y,
                    int angle_in_degrees=0 );
</pre><p><dl>
<dt>M<dd>The array of magnitudes. If it is NULL, the magnitudes are assumed all 1's.
<dt>A<dd>The array of angles, whether in radians or degrees.
<dt>X<dd>The destination array of x-coordinates, may be set to NULL if it is not needed.
<dt>Y<dd>The destination array of y-coordinates, mau be set to NULL if it is not needed.
<dt>angle_in_degrees<dd>The flag indicating whether the angles are measured in radians,
                        which is default mode, or in degrees.
</dl><p>
The function <a href="#decl_cvPolarToCart">cvPolarToCart</a> calculates either x-coodinate, y-coordinate
or both of every vector <em>M(I)*exp(A(I)*j)</em>:</p>
<pre>
X(I)=M(I)*cos(A(I)),
Y(I)=M(I)*sin(A(I))
</pre>


<hr><h3><a name="decl_cvPow">Pow</a></h3>
<p class="Blurb">Raises every array element to power</p>
<pre>
void cvPow( const CvArr* X, CvArr* Y, double p );
</pre><p><dl>
<dt>X<dd>The source array.
<dt>Y<dd>The destination array, should be the same type as the source.
<dt>p<dd>The exponent of power.
</dl><p>
The function <a href="#decl_cvPow">cvPow</a> raises every element of input array to <em>p</em>:</p>
<pre>
Y(I)=X(I)<sup>p</sup>, if <em>p</em> is integer
Y(I)=abs(X(I))<sup>p</sup>, otherwise
</pre>
<p>That is, for non-integer power exponent the absolute values of input
array elements are used. However, it is possible to get true values
for negative values using some extra operations, as the following sample,
computing cube root of array elements, shows:</p>
<pre>
CvSize size = cvGetSize(src);
CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
cvPow( src, dst, 1./3 );
cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
cvReleaseMat( &mask );
</pre>
<p>For some values of <em>power</em>, such as integer values, 0.5 and -0.5,
an optimized algorithm is used.</p>


<hr><h3><a name="decl_cvExp">Exp</a></h3>
<p class="Blurb">Calculates exponent of every array element</p>
<pre>
void cvExp( const CvArr* X, CvArr* Y );
</pre><p><dl>
<dt>X<dd>The source array.
<dt>Y<dd>The destination array, it should have <em>double</em> type or
the same type as the source.
</dl><p>
The function <a href="#decl_cvExp">cvExp</a> calculates exponent of every element of input array:</p>
<pre>
Y(I)=exp(X(I))
</pre>
<p>Maximum relative error is &asymp;7e-6. Currently,
the function converts denormalized values to zeros on output.</p>


<hr><h3><a name="decl_cvLog">Log</a></h3>
<p class="Blurb">Calculates natural logarithm of every array element absolute value</p>
<pre>
void cvLog( const CvArr* X, CvArr* Y );
</pre><p><dl>
<dt>X<dd>The source array.
<dt>Y<dd>The destination array, it should have <em>double</em> type or
the same type as the source.
</dl><p>
The function <a href="#decl_cvLog">cvLog</a> calculates natural logarithm
of absolute value of every element of input array:</p>
<pre>
Y(I)=log(abs(X(I))), X(I)!=0
Y(I)=C,  X(I)=0
</pre>
Where <em>C</em> is large negative number (&asymp;-700 in the current implementation)</p>


<hr><h3><a name="decl_cvCheckArr">CheckArr</a></h3>
<p class="Blurb">Checks every element of input array for invalid values</p>
<pre>
int  cvCheckArr( const CvArr* X, int flags=0,
                 double minVal=0, double maxVal=0);
#define cvCheckArray cvCheckArr
</pre><p><dl>
<dt>X<dd>The array to check.
<dt>flags<dd>The operation flags, 0 or combination of:<br>
             CV_CHECK_RANGE - if set, the function checks that every value of
                              array is within [minVal,maxVal) range,
                              otherwise it just checks that every element
                              is neigther NaN nor &plusmn;&infin;.<br>
             CV_CHECK_QUIET - if set, the function does not raises an
                              error if an element is invalid or out of range
<dt>minVal<dd>The inclusive lower boundary of valid values range.
              It is used only if <em>CV_CHECK_RANGE</em> is set.
<dt>maxVal<dd>The exclusive upper boundary of valid values range.
              It is used only if <em>CV_CHECK_RANGE</em> is set.
</dl><p>
The function <a href="#decl_cvCheckArr">cvCheckArr</a> checks that every array element
is neither NaN nor &plusmn;&infin;.
If <em>CV_CHECK_RANGE</em> is set, it also checks that every element is
greater than or equal to <em>minVal</em> and less than <em>maxVal</em>.
The function returns nonzero if the check succeeded, i.e. all elements
are valid and within the range, and zero otherwise.
In the latter case if <em>CV_CHECK_QUIET</em> flag is not set, the function
raiser runtime error.
</p>


<hr><h3><a name="decl_cvRandInit">RandInit</a></h3>
<p class="Blurb">Initializes random number generator state</p>
<pre>
void cvRandInit( CvRandState* state, double param1, double param2, int seed,
                 int distType=CV_RAND_UNI );
</pre><p><dl>
<dt>state<dd>Pointer to the initialized random number generator state structure.
<dt>param1<dd>The first distribution parameter. In case of uniform distribution it is
              the inclusive lower boundary of random numbers range. In case of
              normal distribution it is the standard deviation of random numbers.
<dt>param2<dd>The second distribution parameter. In case of uniform distribution it is
              the exclusive upper boundary of random numbers range. In case of
              normal distribution it is the mean value of random numbers.
<dt>seed<dd>Initial 32-bit value to start a random sequence.
<dt>distType<dd>Distribution type:<br>
                CV_RAND_UNI - uniform distribution<br>
                CV_RAND_NORMAL - normal or Gaussian distribution<br>
</dl><p>
The function <a href="#decl_cvRandInit">cvRandInit</a> initializes the <em>state</em> structure that is used for
generating uniformly distributed numbers in the range <em>[param1, param2)</em>
or normally distributed numbers with <em>param1</em> mean and
<em>param2</em> standard deviation. The parameters are set for
all the dimensions simultaneously - resemble that RNG has separate parameters
for each of 4 dimensions. A multiply-with-carry generator is used.</p>


<hr><h3><a name="decl_cvRandSetRange">RandSetRange</a></h3>
<p class="Blurb">Changes the range of generated random numbers without touching RNG state</p>
<pre>
void cvRandSetRange( CvRandState* state, double param1, double param2, int index=-1 );
</pre><p><dl>
<dt>state<dd>State of random number generator (RNG).
<dt>param1<dd>New lower boundary/deviation of generated numbers.
<dt>param2<dd>New upper boundary/mean value of generated numbers.
<dt>index<dd>The 0-based index of dimension/channel for which the parameter are changed, -1
            means changing the parameters for all dimensions.
</dl><p>
The function <a href="#decl_cvRandSetRange">cvRandSetRange</a> changes the range of generated random numbers without
reinitializing RNG state. It is useful if a few arrays of different types need to
initialized with random numbers within a loop. Alternatively, you may
have a separate generator for each array, but then you should provide several
uncorrelated initialization seeds - one per each generator.
</p>


<hr><h3><a name="decl_cvRand">Rand</a></h3>
<p class="Blurb">Fills array with random numbers and updates the RNG state</p>
<pre>
void cvRand( CvRandState* state, CvArr* arr );
</pre><p><dl>
<dt>state<dd>RNG state initialized by <em>RandInit</em> and, optionally,
customized by <em>RandSetRange</em>.
<dt>arr<dd>The destination array.
</dl><p>
The function <a href="#decl_cvRand">cvRand</a> fills the destination array with uniformly or normally distributed random
numbers within the pre-set range and updates RNG state. In the sample below
this and two functions above are used to put a few normally distributed
floating-point numbers to random locations within a 2d array</p>
<pre>
/* let's noisy_screen be the floating-point 2d array that is to be "crapped" */
CvRandState rng_state;
int i, pointCount = 1000;
/* allocate the array of coordinates of points */
CvMat* locations = cvCreateMat( pointCount, 1, CV_32SC2 );
/* array of random point values */
CvMat* values = cvCreateMat( pointCount, 1, CV_32FC1 );
CvSize size = cvGetSize( noisy_screen );

cvRandInit( &rng_state,
            0, 1, /* use dummy parameters now and adjust them further */
            0xffffffff /* just use a fixed seed here */,
            CV_RAND_UNI /* specify uniform type */ );

/* customize the RNG to use it for initialiazing locations:
   the 0-th dimension is used for x's and the 1st - for y's */
cvRandSetRange( &rng_state, 0, size.width, 0 );
cvRandSetRange( &rng_state, 0, size.height, 1 );

/* initialize the locations */
cvRand( &rng_state, locations );

/* modify RNG to make it produce normally distributed values */
rng_state.disttype = CV_RAND_NORMAL;
cvRandSetRange( &rng_state,
                30 /* deviation */,
                100 /* average point brightness */,
                -1 /* initialize all the dimensions */ );
/* generate values */
cvRand( &rng_state, values );

/* set the points */
for( i = 0; i &lt; pointCount; i++ )
{
    CvPoint pt = *(CvPoint*)cvPtr1D( locations, i, 0 );
    float value = *(float*)cvPtr1D( values, i, 0 );
    cvSetReal2D( noisy_screen, pt.y, pt.x, value );
}

/* not to forget to release the temporary arrays */
cvReleaseMat( &locations );
cvReleaseMat( &values );

/* cvRandInit does not allocate any memory, so there is no need
  (and no function) to deinitialize it */
</pre>



<hr><h3><a name="decl_cvRandNext">RandNext</a></h3>
<p class="Blurb">Returns 32-bit unsigned integer and updates RNG</p>
<pre>
unsigned cvRandNext( CvRandState* state );
</pre><p><dl>
<dt>state<dd>RNG state initialized by <em>RandInit</em> and, optionally,
customized by <em>RandSetRange</em> (though, the latter function does not
affect on the discussed function outcome).
</dl><p>
The function <a href="#decl_cvRandNext">cvRandNext</a> returns uniformly-distributed (regardless
of the RNG distribution type settings) "plain" integer random number
and updates RNG state. It is similar to rand() function from C runtime library,
but it always generates 32-bit number whereas rand() returns a number in between 0
and <em>RAND_MAX</em> which is 2**16 or 2**32, depending on the platform.</p><p>
The function is useful for generating scalar random numbers, such as points, patch sizes,
table indices etc, where integer numbers of a certain range can be generated using
modulo operation and floating-point numbers can be generated by scaling to
0..1 of any other specific range. Here is the example from the previous function discussion
rewritten using <a href="#decl_cvRandNext">cvRandNext</a>:</p>
<pre>
/* the input and the task is the same as in the previous sample. */
CvRandState rng_state;
int i, pointCount = 1000;
/* ... - no arrays are allocated here */
CvSize size = cvGetSize( noisy_screen );
/* make a buffer for normally distributed numbers to reduce call overhead */
#define bufferSize 16
float normalValueBuffer[bufferSize];
CvMat normalValueMat = cvMat( bufferSize, 1, CV_32F, normalValueBuffer );
int valuesLeft = 0;

/* initialize RNG to produce normally distributed values.
   Coordinates will be uniformly distributed within 0..2**32
   anyway as they are generated using cvRandNext */
cvRandInit( &rng_state,
            100,
            30,
            0xffffffff /* just use a fixed seed here */,
            CV_RAND_NORMAL /* specify uniform type */ );

for( i = 0; i &lt; pointCount; i++ )
{
    CvPoint pt;
    /* generate random point */
    pt.x = cvRandNext( &rng_state ) % size.width;
    pt.y = cvRandNext( &rng_state ) % size.height;

    if( valuesLeft &lt;= 0 )
    {
        /* fulfill the buffer with normally distributed numbers if the buffer is empty */
        cvRand( &rng_state, &normalValueMat );
        valuesLeft = bufferSize;
    }
    cvSetReal2D( noisy_screen, pt.y, pt.x, normalValueBuffer[--valuesLeft]);
}

/* there is no need to deallocate normalValueMat because we have
both the matrix header and the data on stack. It is a common and efficient
practice of working with small, fixed-size matrices */
</pre>


<hr><h3><a name="decl_cvDFT">DFT</a></h3>
<p class="Blurb">Performs forward or inverse Discrete Fourier transform of 1D or 2D floating-point array</p>
<pre>
#define CV_DXT_INVERSE  1
#define CV_DXT_SCALE 2
#define CV_DXT_INV_SCALE (CV_DXT_SCALE|CV_DXT_INVERSE)
#define CV_DXT_INVERSE_SCALE CV_DXT_INV_SCALE

void cvDFT( const CvArr* src, CvArr* dst, int flags );
</pre><p><dl>
<dt>src<dd>Source array, real or complex.
<dt>dst<dd>Destination array of the same size and same type as the source.
<dt>flags<dd>Transformation flags, 0 or a combination of the following flags:<br>
              CV_DXT_INVERSE - perform inverse transform (w/o post-scaling><br>
              CV_DXT_SCALE - divide the result by the number of array elements<br>
             For convenience, the constant CV_DXT_FORWARD may be used instead of literal 0.
</dl><p>
The function <a href="#decl_cvDFT">cvDFT</a> performs forward or inverse transform of
1D or 2D floating-point array:
<pre>
Forward Fourier transform of 1D vector of N elements:
y = F&bull;x, where F<sub>ik</sub>=exp(-j&bull;Pi&bull;i&bull;k/N), j=sqrt(-1)

Inverse Fourier transform of 1D vector of N elements:
x = F<sup>-1</sup>&bull;y = F<sup>T</sup>&bull;y

Forward Fourier transform of 2D vector of M&times;N elements:
Y = F&bull;X&bull;F<sup>*</sup>

Inverse Fourier transform of 2D vector of M&times;N elements:
X = F<sup>*</sup>&bull;Y&bull;F
</pre>

<p>In case of real (single-channel) data, the packed format, borrowed from IPL, is used to
to represent a result of forward Fourier transform or input for inverse Fourier transform:

<pre>
Re Y<sub>0,0</sub>      Re Y<sub>0,1</sub>    Im Y<sub>0,1</sub>    Re Y<sub>0,2</sub>     Im Y<sub>0,2</sub>  ...  Re Y<sub>0,N/2-1</sub>   Im Y<sub>0,N/2-1</sub>  Re Y<sub>0,N/2</sub>
Re Y<sub>1,0</sub>      Re Y<sub>1,1</sub>    Im Y<sub>1,1</sub>    Re Y<sub>1,2</sub>     Im Y<sub>1,2</sub>  ...  Re Y<sub>1,N/2-1</sub>   Im Y<sub>1,N/2-1</sub>  Re Y<sub>1,N/2</sub>
Im Y<sub>2,0</sub>      Re Y<sub>2,1</sub>    Im Y<sub>2,1</sub>    Re Y<sub>2,2</sub>     Im Y<sub>2,2</sub>  ...  Re Y<sub>2,N/2-1</sub>   Im Y<sub>2,N/2-1</sub>  Im Y<sub>2,N/2</sub>
............................................................................................
Re Y<sub>M/2-1,0</sub>   Re Y<sub>M-3,1</sub>   Im Y<sub>M-3,1</sub>  Re Y<sub>M-3,2</sub>   Im Y<sub>M-3,2</sub> ...  Re Y<sub>M-3,N/2-1</sub>  Im Y<sub>M-3,N/2-1</sub> Re Y<sub>M-3,N/2</sub>
Im Y<sub>M/2-1,0</sub>   Re Y<sub>M-2,1</sub>   Im Y<sub>M-2,1</sub>  Re Y<sub>M-2,2</sub>   Im Y<sub>M-2,2</sub> ...  Re Y<sub>M-2,N/2-1</sub>  Im Y<sub>M-2,N/2-1</sub> Im Y<sub>M-2,N/2</sub>
Re Y<sub>M/2,0</sub>    Re Y<sub>M-1,1</sub>   Im Y<sub>M-1,1</sub>  Re Y<sub>M-1,2</sub>   Im Y<sub>M-1,2</sub>  ... Re Y<sub>M-1,N/2-1</sub>  Im Y<sub>M-1,N/2-1</sub> Im Y<sub>M-1,N/2</sub>
</pre>

<p>Note: the last column is present if <code>N</code> is even, the last row is present if <code>M</code> is even.</p>
<p>In case of 1D real transform the result looks like the first row of the above matrix</p>

<hr><h3><a name="decl_cvMulCss">MulCss</a></h3>
<p class="Blurb">Performs per-element multiplication of two Fourier spectrums of two real arrays</p>
<pre>
void cvMulCss( const CvArr* srcA, const CvArr* srcB, CvArr* dst );
</pre><p><dl>
<dt>srcA<dd>The first source array.
<dt>srcB<dd>The second source array.
<dt>dst<dd>The destination array of the same type and the same size of the sources.
</dl><p>
The function <a href="#decl_cvMulCss">cvMulCss</a> performs per-element multiplication of the
two packed matrices that are produced by forward real Fourier transform (1D or 2D).
</p><p>
Calculating DFT's of two real arrays, then multiplying results by <em>cvMulCss</em> and
performing inverse DFT on the product is equivalent yet faster way to find
cyclic convolution of the two original arrays.
</p>

<hr><h3><a name="decl_cvDCT">DCT</a></h3>
<p class="Blurb">Performs forward or inverse Discrete Cosine transform of 1D or 2D floating-point array</p>
<pre>
#define CV_DXT_INVERSE  1
#define CV_DXT_SCALE 2
#define CV_DXT_INV_SCALE (CV_DXT_SCALE|CV_DXT_INVERSE)
#define CV_DXT_INVERSE_SCALE CV_DXT_INV_SCALE

void cvDCT( const CvArr* src, CvArr* dst, int flags );
</pre><p><dl>
<dt>src<dd>Source array, real 1D or 2D array.
<dt>dst<dd>Destination array of the same size and same type as the source.
<dt>flags<dd>Transformation flags, 0 or a combination of the following flags:<br>
              CV_DXT_INVERSE - perform inverse transform<br>
              CV_DXT_SCALE - divide the result by the number of array elements<br>
             For convenience, the constant CV_DXT_FORWARD may be used instead of literal 0.
</dl><p>
The function <a href="#decl_cvDCT">cvDCT</a> performs forward or inverse transform of
1D or 2D floating-point array:
<pre>
Forward Cosine transform of 1D vector of N elements:
y = C&bull;x, where C<sub>ik</sub>=sqrt((i==0?1:2)/N)&bull;cos(Pi&bull;(2i+1)&bull;k/N), j=sqrt(-1)

Inverse Cosine transform of 1D vector of N elements:
x = C<sup>-1</sup>&bull;y = C<sup>T</sup>&bull;y

Forward Cosine transform of 2D vector of M&times;N elements:
Y = C&bull;X&bull;C<sup>T</sup>

Inverse Fourier transform of 2D vector of M&times;N elements:
X = C<sup>T</sup>&bull;Y&bull;C
</pre>


<hr><h2><a name="ch1_dynamic_structs">Dynamic Data Structures</a></h2>

<hr><h3><a name="decl_CvMemStorage">CvMemStorage</a></h3>
<p class="Blurb">Growing memory storage</p>
<pre>
    typedef struct CvMemStorage
    {
        struct CvMemBlock* bottom;/* first allocated block */
        struct CvMemBlock* top; /* the current memory block - top of the stack */
        struct CvMemStorage* parent; /* borrows new blocks from */
        int block_size; /* block size */
        int free_space; /* free space in the <em>top</em> block (in bytes) */
    } CvMemStorage;
</pre>
<p>
Memory storage is a low-level structure used to store dynamically growing data structures such as
sequences, contours, graphs, subdivisions etc. It is organized as a list of memory blocks of
equal size - <em>bottom</em> field is the beginning of the list of blocks</em>
and <em>top</em> is the currently used block, but not necessarily the last block of the list. All blocks
between <em>bottom</em> and <em>top</em>, not including the latter, are considered fully ocupied;
and all blocks between <em>top</em> and the last block, not including <em>top</em>,
are considered free and <em>top</em> block itself is partly ocupied - <em>free_space</em>
contains the number of free bytes left in the end of <em>top</em>.
</p><p>New memory buffer that may be allocated explicitly by <a href="#decl_cvMemStorageAlloc">cvMemStorageAlloc</a> function
or implicitly by
higher-level functions, such as <a href="#decl_cvSeqPush">cvSeqPush</a>, <a href="#decl_cvGraphAddEdge">cvGraphAddEdge</a> etc., <em>always</em>
starts in the end of the current block if it fits there. After allocation <em>free_space</em>
is decremented by the size of the allocated buffer plus some padding to keep the proper alignment.
When the allocated buffer does not fit into the available part of <em>top</em>, the next storage
block from the list is taken as <em>top</em> and <em>free_space</em> is reset to the
whole block size prior to the allocation.</p><p>
If there is no more free blocks, a new block is allocated (or borrowed from parent, see
<a href="#decl_cvCreateChildMemStorage">cvCreateChildMemStorage</a>) and added to the end of list. Thus, the storage behaves as a stack
with <em>bottom</em> indicating bottom of the stack and the pair (<em>top</em>, <em>free_space</em>)
indicating top of the stack. The stack top may be saved via <a href="#decl_cvSaveMemStoragePos">cvSaveMemStoragePos</a>,
restored via <a href="#decl_cvRestoreMemStoragePos">cvRestoreMemStoragePos</a> or reset via <a href="#decl_cvClearStorage">cvClearStorage</a>.
</p>


<hr><h3><a name="decl_CvMemBlock">CvMemBlock</a></h3>
<p class="Blurb">Memory storage block</p>
<pre>
    typedef struct CvMemBlock
    {
        struct CvMemBlock* prev;
        struct CvMemBlock* next;
    } CvMemBlock;
</pre>
<p>
The structure <a href="#decl_CvMemBlock">CvMemBlock</a> represents a single block of memory storage.
Actual data of the memory blocks follows the header, that is, the <em>i-th</em> byte of
the memory block can be retrieved with the expression <em>((char*)(mem_block_ptr+1))[i]</em>.
However, normally there is no need to access the storage structure fields directly.
</p>


<hr><h3><a name="decl_CvMemStoragePos">CvMemStoragePos</a></h3>
<p class="Blurb">Memory storage position</p>
<pre>
    typedef struct CvMemStoragePos
    {
        CvMemBlock* top;
        int free_space;
    } CvMemStoragePos;
</pre>
<p>
The structure described below stores the position of the stack top that can be
saved via <a href="#decl_cvSaveMemStoragePos">cvSaveMemStoragePos</a> and restored via <a href="#decl_cvRestoreMemStoragePos">cvRestoreMemStoragePos</a>.</p>


<hr><h3><a name="decl_cvCreateMemStorage">CreateMemStorage</a></h3>
<p class="Blurb">Creates memory storage</p>
<pre>
CvMemStorage* cvCreateMemStorage( int blockSize=0 );
</pre><p><dl>
<dt>blockSize<dd>Size of the storage blocks in bytes. If it is 0, the block size is set to default value
- currently it is &asymp;64K.
</dl><p>
The function <a href="#decl_cvCreateMemStorage">cvCreateMemStorage</a> creates a memory storage and returns pointer
to it. Initially the storage is empty. All fields of the header, except the <em>block_size</em>,
are set to 0.</p>


<hr><h3><a name="decl_cvCreateChildMemStorage">CreateChildMemStorage</a></h3>
<p class="Blurb">Creates child memory storage</p>
<pre>
CvMemStorage* cvCreateChildMemStorage( CvMemStorage* parent );
</pre><p><dl>
<dt>parent<dd>Parent memory storage.
</dl><p>
The function <a href="#decl_cvCreateChildMemStorage">cvCreateChildMemStorage</a> creates a child memory storage that is similar
to simple memory storage except for the differences in the memory
allocation/deallocation mechanism. When a child storage needs a new block to
add to the block list, it tries to get this block from the parent. The first
unoccupied parent block available is taken and excluded from the parent block
list. If no blocks are available, the parent either allocates a block or borrows
one from its own parent, if any. In other words, the chain, or a more complex
structure, of memory storages where every storage is a child/parent of another
is possible. When a child storage is released or even cleared, it returns all
blocks to the parent. In other aspects, the child storage is the same as the simple storage.</p>
<p>
The children storages are useful in the following situation.
Imagine that user needs to process dynamical data resided in some storage and
put the result back to the same storage. With the simplest approach, when temporary
data is resided in the same storage as the input and output data, the storage
will look as following after processing:</p>
<p>
<font color=blue>Dynamic data processing without using child storage</font>
</p>
<p>
<img align="center" src="pics/memstorage1.png" >
</p>
<p>
That is, garbage appears in the middle of the storage.
However, if one creates a child memory storage in the beginning of the processing,
writes temporary data there and releases the child storage in the end, no garbage will
appear in the source/destination storage:</p>
<p><font color=blue>Dynamic data processing using a child storage</font>
</p><p>
<img align="center" src="pics/memstorage2.png" >
</p>


<hr><h3><a name="decl_cvReleaseMemStorage">ReleaseMemStorage</a></h3>
<p class="Blurb">Releases memory storage</p>
<pre>
void cvReleaseMemStorage( CvMemStorage** storage );
</pre><p><dl>
<dt>storage<dd>Pointer to the released storage.
</dl><p>
The function <a href="#decl_cvReleaseMemStorage">cvReleaseMemStorage</a> deallocates all storage memory blocks or returns
them to the parent, if any. Then it deallocates the storage header and clears
the pointer to the storage. All children of the storage must be released before
the parent is released.</p>


<hr><h3><a name="decl_cvClearMemStorage">ClearMemStorage</a></h3>
<p class="Blurb">Clears memory storage</p>
<pre>
void cvClearMemStorage( CvMemStorage* storage );
</pre><p><dl>
<dt>storage<dd>Memory storage.
</dl><p>
The function <a href="#decl_cvClearMemStorage">cvClearMemStorage</a> resets the top (free space boundary) of the storage
to the very beginning. This function does not deallocate any memory. If the
storage has a parent, the function returns all blocks to the parent.</p>


<hr><h3><a name="decl_cvMemStorageAlloc">MemStorageAlloc</a></h3>
<p class="Blurb">Allocates memory buffer in the storage</p>
<pre>
void* cvMemStorageAlloc( CvMemStorage* storage, int size );
</pre><p><dl>
<dt>storage<dd>Memory storage.
<dt>size<dd>Buffer size.
</dl><p>
The function <a href="#decl_cvMemStorageAlloc">cvMemStorageAlloc</a> allocates memory buffer in the storage. The buffer size
must not exceed the storage block size, otherwise runtime error is raised. The buffer address is
aligned by <em>CV_STRUCT_ALIGN</em> (=<em>sizeof(double)</em> for the moment) bytes.
</p>


<hr><h3><a name="decl_cvSaveMemStoragePos">SaveMemStoragePos</a></h3>
<p class="Blurb">Saves memory storage position</p>
<pre>
void cvSaveMemStoragePos( const CvMemStorage* storage, CvMemStoragePos* pos );
</pre><p><dl>
<dt>storage<dd>Memory storage.
<dt>pos<dd>The output position of the storage top.
</dl><p>
The function <a href="#decl_cvSaveMemStoragePos">cvSaveMemStoragePos</a> saves the current position of the storage top to
the parameter <em>pos</em>. The function <a href="#decl_cvRestoreMemStoragePos">cvRestoreMemStoragePos</a> can further retrieve
this position.</p>


<hr><h3><a name="decl_cvRestoreMemStoragePos">RestoreMemStoragePos</a></h3>
<p class="Blurb">Restores memory storage position</p>
<pre>
void cvRestoreMemStoragePos( CvMemStorage* storage, CvMemStoragePos* pos );
</pre><p><dl>
<dt>storage<dd>Memory storage.
<dt>pos<dd>New storage top position.
</dl><p>
The function <a href="#decl_cvRestoreMemStoragePos">cvRestoreMemStoragePos</a> restores the position of the storage top from
the parameter <em>pos</em>. This function and the function <a href="#decl_cvClearMemStorage">cvClearMemStorage</a> are the
only methods to release memory occupied in memory blocks.
Note again that there is no way to free memory in the middle of the occupied part of the storage.
</p>


<hr><h2><a name="ch1_seqs">Sequences</a></h2>

<hr><h3><a name="decl_CvSeq">CvSeq</a></h3>
<p class="Blurb">Growable sequence of elements</p>
<pre>
    #define CV_SEQUENCE_FIELDS() \
        int flags; /* micsellaneous flags */ \
        int header_size; /* size of sequence header */ \
        struct CvSeq* h_prev; /* previous sequence */ \
        struct CvSeq* h_next; /* next sequence */ \
        struct CvSeq* v_prev; /* 2nd previous sequence */ \
        struct CvSeq* v_next; /* 2nd next sequence */ \
        int total; /* total number of elements */ \
        int elem_size;/* size of sequence element in bytes */ \
        char* block_max;/* maximal bound of the last block */ \
        char* ptr; /* current write pointer */ \
        int delta_elems; /* how many elements allocated when the sequence grows (sequence granularity) */ \
        CvMemStorage* storage; /* where the seq is stored */ \
        CvSeqBlock* free_blocks; /* free blocks list */ \
        CvSeqBlock* first; /* pointer to the first sequence block */


    typedef struct CvSeq
    {
        CV_SEQUENCE_FIELDS()
    } CvSeq;
</pre>
<p>
The structure <a href="#decl_CvSeq">CvSeq</a> is a base for all of OpenCV dynamic data structures.</p>
<p>Such an unusual definition via a helper macro simplifies the extension of the structure
<a href="#decl_CvSeq">CvSeq</a> with additional parameters.
To extend <a href="#decl_CvSeq">CvSeq</a> the user may define a new structure and
put user-defined fields after all <a href="#decl_CvSeq">CvSeq</a> fields that are included via the macro
<em>CV_SEQUENCE_FIELDS()</em>.</p>
<p>There are two types of sequences - dense and sparse. Base type for dense sequences is <a href="#decl_CvSeq">CvSeq</a>
and such sequences are used to represent growable 1d arrays - vectors, stacks, queues, deques.
They have no gaps in the middle - if an element is removed from the middle or inserted into the middle
of the sequence the elements from the closer end are shifted.
Sparse sequences have <a href="#decl_CvSet">CvSet</a> base
class and they are discussed later in more details. They are sequences of nodes each of those may be
either occupied or free as indicated by the node flag. Such sequences are used for unordered data
structures such as sets of elements, graphs, hash tables etc.</p>

<p>The field <em>header_size</em> contains the actual size of the
sequence header and should be greater or equal to <em>sizeof(CvSeq)</em>.</p><p>The fields
<em>h_prev, h_next, v_prev, v_next</em> can be used to create hierarchical structures
from separate sequences. The fields <em>h_prev</em> and <em>h_next</em> point to the previous and
the next sequences on the same hierarchical level while the fields <em>v_prev</em> and
<em>v_next</em> point to the previous and the next sequence in the vertical direction,
that is, parent and its first child. But these are just names and the pointers
can be used in a different way.</p><p>The field <em>first</em> points to the first sequence
block, whose structure is described below.</p>
<p>The field <em>total</em> contains the actual number of dense sequence elements and
number of allocated nodes in sparse sequence.</p>
<p>The field <em>flags</em>contain the particular dynamic type
signature (<em>CV_SEQ_MAGIC_VAL</em> for dense sequences and <em>CV_SET_MAGIC_VAL</em> for sparse sequences)
in the highest 16 bits and miscellaneous information about the sequence.
The lowest <em>CV_SEQ_ELTYPE_BITS</em> bits contain the ID of the
element type. Most of sequence processing functions do not use element type
but element size stored in <em>elem_size</em>.
If sequence contains the numeric data of one of <a href="#decl_CvMat">CvMat</a> type
then the element type matches to the corresponding <a href="#decl_CvMat">CvMat</a> element type, e.g.
CV_32SC2 may be used for sequence of 2D points, CV_32FC1 for sequences of floating-point values etc.
<em>CV_SEQ_ELTYPE(seq_header_ptr)</em> macro retrieves the type of sequence elements.
Processing function that work with numerical sequences check that <em>elem_size</em> is equal
to the calculated from the type element size.
Besides <a href="#decl_CvMat">CvMat</a> compatible types, there are few extra element types defined
in <a href="#decl_cvtypes.h">cvtypes.h</a> header:</p>
<p><font color=blue>Standard Types of Sequence Elements</font></p>
<pre>
    #define CV_SEQ_ELTYPE_POINT          CV_32SC2  /* (x,y) */
    #define CV_SEQ_ELTYPE_CODE           CV_8UC1   /* freeman code: 0..7 */
    #define CV_SEQ_ELTYPE_GENERIC        0 /* unspecified type of sequence elements */
    #define CV_SEQ_ELTYPE_PTR            CV_USRTYPE1 /* =6 */
    #define CV_SEQ_ELTYPE_PPOINT         CV_SEQ_ELTYPE_PTR  /* &elem: pointer to element of other sequence */
    #define CV_SEQ_ELTYPE_INDEX          CV_32SC1  /* #elem: index of element of some other sequence */
    #define CV_SEQ_ELTYPE_GRAPH_EDGE     CV_SEQ_ELTYPE_GENERIC  /* &next_o, &next_d, &vtx_o, &vtx_d */
    #define CV_SEQ_ELTYPE_GRAPH_VERTEX   CV_SEQ_ELTYPE_GENERIC  /* first_edge, &(x,y) */
    #define CV_SEQ_ELTYPE_TRIAN_ATR      CV_SEQ_ELTYPE_GENERIC  /* vertex of the binary tree   */
    #define CV_SEQ_ELTYPE_CONNECTED_COMP CV_SEQ_ELTYPE_GENERIC  /* connected component  */
    #define CV_SEQ_ELTYPE_POINT3D        CV_32FC3  /* (x,y,z)  */
</pre>
<p>
The next <em>CV_SEQ_KIND_BITS</em> bits specify the kind of the sequence:</p>
<p><font color=blue>Standard Kinds of Sequences</font></p>
<pre>
    /* generic (unspecified) kind of sequence */
    #define CV_SEQ_KIND_GENERIC     (0 &lt;&lt; CV_SEQ_ELTYPE_BITS)

    /* dense sequence suntypes */
    #define CV_SEQ_KIND_CURVE       (1 &lt;&lt; CV_SEQ_ELTYPE_BITS)
    #define CV_SEQ_KIND_BIN_TREE    (2 &lt;&lt; CV_SEQ_ELTYPE_BITS)

    /* sparse sequence (or set) subtypes */
    #define CV_SEQ_KIND_GRAPH       (3 &lt;&lt; CV_SEQ_ELTYPE_BITS)
    #define CV_SEQ_KIND_SUBDIV2D    (4 &lt;&lt; CV_SEQ_ELTYPE_BITS)
</pre>
<p>
The remaining bits are used to identify different features specific to certain
sequence kinds and element types. For example, curves made of points (
<em>CV_SEQ_KIND_CURVE|CV_SEQ_ELTYPE_POINT</em> ), together with the flag
<em>CV_SEQ_FLAG_CLOSED</em> belong to the type <em>CV_SEQ_POLYGON</em> or, if other flags are
used, to its subtype. Many contour processing functions check the type of the input
sequence and report an error if they do not support this type. The file
<a href="#decl_cvtypes.h">cvtypes.h</a> stores the complete list of all supported predefined sequence types
and helper macros designed to get the sequence type of other properties.
Below follows the definition of the building block of sequences.</p>


<hr><h3><a name="decl_CvSeqBlock">CvSeqBlock</a></h3>
<p class="Blurb">Continuous sequence block</p>
<pre>
    typedef struct CvSeqBlock
    {
        struct CvSeqBlock* prev; /* previous sequence block */
        struct CvSeqBlock* next; /* next sequence block */
        int start_index; /* index of the first element in the block +
        sequence->first->start_index */
        int count; /* number of elements in the block */
        char* data; /* pointer to the first element of the block */
    } CvSeqBlock;
</pre>
<p>
Sequence blocks make up a circular double-linked list, so the pointers <em>prev</em> and
<em>next</em> are never <em>NULL</em> and point to the previous and the next sequence blocks
within the sequence. It means that <em>next</em> of the last block is the first block and
<em>prev</em> of the first block is the last block. The fields <em>start_index</em> and <em>count</em> help
to track the block location within the sequence. For example, if the sequence
consists of 10 elements and splits into three blocks of 3, 5, and 2 elements,
and the first block has the parameter <em>start_index = 2</em>, then pairs <em>(start_index, count)</em>
for the sequence blocks are <em>(2,3), (5, 5)</em>, and <em>(10, 2)</em>
correspondingly. The parameter <em>start_index</em> of the first block is usually <em>0</em>
unless some elements have been inserted at the beginning of the sequence.
</p>


<hr><h3><a name="decl_cvCreateSeq">CreateSeq</a></h3>
<p class="Blurb">Creates sequence</p>
<pre>
CvSeq* cvCreateSeq( int seqFlags, int headerSize,
                    int elemSize, CvMemStorage* storage );
</pre><p><dl>
<dt>seqFlags<dd>Flags of the created sequence. If the sequence is not passed to any
function working with a specific type of sequences, the sequence value may be
set to 0, otherwise the appropriate type must be selected from the list of
predefined sequence types.
<dt>headerSize<dd>Size of the sequence header; must be greater or equal to
<em>sizeof(CvSeq)</em>. If a specific type or its extension is indicated, this type must
fit the base type header.
<dt>elemSize<dd>Size of the sequence elements in bytes. The size must be consistent
with the sequence type. For example, for a sequence of points to be created, the
element type <em>CV_SEQ_ELTYPE_POINT</em> should be specified and the parameter <em>elemSize</em>
must be equal to <em>sizeof(CvPoint)</em>.
<dt>storage<dd>Sequence location.
</dl><p>
The function <a href="#decl_cvCreateSeq">cvCreateSeq</a> creates a sequence and returns the pointer to it. The
function allocates the sequence header in the storage block as one continuous
chunk and fills the parameter <em>elemSize</em>, flags <em>headerSize</em>, and <em>storage</em> with
passed values, sets <em>delta_elems</em> to the default value (that may be reassigned using
<a href="#decl_cvSetSeqBlockSize">cvSetSeqBlockSize</a> function), and clears other fields, including the space behind <em>sizeof(CvSeq)</em>.</p>


<hr><h3><a name="decl_cvSetSeqBlockSize">SetSeqBlockSize</a></h3>
<p class="Blurb">Sets up sequence block size</p>
<pre>
void cvSetSeqBlockSize( CvSeq* seq, int blockSize );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>blockSize<dd>Desirable block size.
</dl><p>
The function <a href="#decl_cvSetSeqBlockSize">cvSetSeqBlockSize</a> affects the memory allocation granularity. When the
free space in the sequence buffers has run out, the function allocates
<em>blockSize</em> bytes in the storage. If this block immediately follows the one
previously allocated, the two blocks are concatenated, otherwise, a new sequence
block is created. Therefore, the bigger the parameter is, the lower the possible sequence
fragmentation, but the more space in the storage is wasted. When the
sequence is created, the parameter <em>blockSize</em> is set to the default value &asymp;1K.
The function can be called any time after the sequence is created and affects
future allocations. The final block size can be different from the one desired,
e.g., if it is larger than the storage block size, or smaller than the sequence
block header size plus the sequence element size.
</p>


<hr><h3><a name="decl_cvSeqPush">SeqPush</a></h3>
<p class="Blurb">Adds element to sequence end</p>
<pre>
char* cvSeqPush( CvSeq* seq, void* element=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>element<dd>Added element.
</dl><p>
The function <a href="#decl_cvSeqPush">cvSeqPush</a> adds an element to the end of sequence and retuns pointer
to the allocated element. If the input <em>element</em> is NULL,
the function simply allocates a space for one more element.</p>
<p>The following code demonstrates how to create a new sequence using this function:</p>
<pre>
CvMemStorage* storage = cvCreateMemStorage(0);
CvSeq* seq = cvCreateSeq( CV_32SC1, /* sequence of integer elements */
                          sizeof(CvSeq), /* header size - no extra fields */
                          sizeof(int), /* element size */
                          storage /* the container storage */ );
int i;
for( i = 0; i &lt; 100; i++ )
{
    int* added = (int*)cvSeqPush( seq, &i );
    printf( "%d is added\n", *added );
}

...
/* release memory storage in the end */
cvReleaseMemStorage( &storage );
</pre>
<p>
The function <a href="#decl_cvSeqPush">cvSeqPush</a> has O(1) complexity, but there is a faster method for
writing large sequences (see <a href="#decl_cvStartWriteSeq">cvStartWriteSeq</a> and related functions).
</p>

<hr><h3><a name="decl_cvSeqPop">SeqPop</a></h3>
<p class="Blurb">Removes element from sequence end</p>
<pre>
void cvSeqPop( CvSeq* seq, void* element=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>element<dd>Optional parameter. If the pointer is not zero, the function copies the
removed element to this location.
</dl><p>
The function <a href="#decl_cvSeqPop">cvSeqPop</a> removes an element from the sequence. The function reports
an error if the sequence is already empty. The function has O(1) complexity. </p>


<hr><h3><a name="decl_cvSeqPushFront">SeqPushFront</a></h3>
<p class="Blurb">Adds element to sequence beginning</p>
<pre>
char* cvSeqPushFront( CvSeq* seq, void* element=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>element<dd>Added element.
</dl><p>
The function <a href="#decl_cvSeqPushFront">cvSeqPushFront</a> is similar to <a href="#decl_cvSeqPush">cvSeqPush</a> but it adds the new element
to the beginning of the sequence. The function has O(1) complexity.
</p>


<hr><h3><a name="decl_cvSeqPopFront">SeqPopFront</a></h3>
<p class="Blurb">Removes element from sequence beginning</p>
<pre>
void cvSeqPopFront( CvSeq* seq, void* element=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>element<dd>Optional parameter. If the pointer is not zero, the function copies the
removed element to this location.
</dl><p>
The function <a href="#decl_cvSeqPopFront">cvSeqPopFront</a> removes an element from the beginning of the sequence.
The function reports an error if the sequence is already empty. The function has O(1) complexity. </p>


<hr><h3><a name="decl_cvSeqPushMulti">SeqPushMulti</a></h3>
<p class="Blurb">Pushes several elements to the either end of sequence</p>
<pre>
void cvSeqPushMulti( CvSeq* seq, void* elements, int count, int in_front=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>elements<dd>Added elements.
<dt>count<dd>Number of elements to push.
<dt>in_front<dd>The flags specifying the modified sequence end:<br>
                CV_BACK (=0) - the elements are added to the end of sequence<br>
                CV_FRONT(!=0) - the elements are added to the beginning of sequence<br>
</dl><p>
The function <a href="#decl_cvSeqPushMulti">cvSeqPushMulti</a> adds several elements to either end of the sequence.
The elements are added to the sequence in the same order as they are arranged in the
input array but they can fall into different sequence blocks.</p>


<hr><h3><a name="decl_cvSeqPopMulti">SeqPopMulti</a></h3>
<p class="Blurb">Removes several elements from the either end of sequence</p>
<pre>
void cvSeqPopMulti( CvSeq* seq, void* elements, int count, int in_front=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>elements<dd>Removed elements.
<dt>count<dd>Number of elements to pop.
<dt>in_front<dd>The flags specifying the modified sequence end:<br>
                CV_BACK (=0) - the elements are removed from the end of sequence<br>
                CV_FRONT(!=0) - the elements are removed from the beginning of sequence<br>
</dl><p>
The function <a href="#decl_cvSeqPopMulti">cvSeqPopMulti</a> removes several elements from either end of the sequence.
If the number of the elements to be removed exceeds the total number of elements
in the sequence, the function removes as many elements as possible.</p>


<hr><h3><a name="decl_cvSeqInsert">SeqInsert</a></h3>
<p class="Blurb">Inserts element in sequence middle</p>
<pre>
char* cvSeqInsert( CvSeq* seq, int beforeIndex, void* element=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>beforeIndex<dd>Index before which the element is inserted. Inserting before 0 (the minimal allowed value
of the parameter) is equal to <a href="#decl_cvSeqPushFront">cvSeqPushFront</a> and inserting before <em>seq->total</em> (the maximal
allowed value of the parameter) is equal to <a href="#decl_cvSeqPush">cvSeqPush</a>.
<dt>element<dd>Inserted element.
</dl><p>
The function <a href="#decl_cvSeqInsert">cvSeqInsert</a> shifts the sequence elements from the inserted position
to the nearest end of the sequence and copies the <em>element</em> content there if
the pointer is not NULL. The function returns pointer to the inserted element.</p>


<hr><h3><a name="decl_cvSeqRemove">SeqRemove</a></h3>
<p class="Blurb">Removes element from sequence middle</p>
<pre>
void cvSeqRemove( CvSeq* seq, int index );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>index<dd>Index of removed element.
</dl><p>
The function <a href="#decl_cvSeqRemove">cvSeqRemove</a> removes elements with the given index. If the index is
out of range the function reports an error.
An attempt to remove an element from an empty sequence is a
partitial case of this situation. The function removes an element by shifting the
sequence elements between the nearest end of the sequence and the <em>index</em>-th position, not
counting the latter.</p>


<hr><h3><a name="decl_cvClearSeq">ClearSeq</a></h3>
<p class="Blurb">Clears sequence</p>
<pre>
void cvClearSeq( CvSeq* seq );
</pre><p><dl>
<dt>seq<dd>Sequence.
</dl><p>
The function <a href="#decl_cvClearSeq">cvClearSeq</a> removes all elements from the sequence. The function does not return the
memory to the storage, but this memory is reused later when new elements are added
to the sequence. This function time complexity is <em>O(1)</em>.


<hr><h3><a name="decl_cvGetSeqElem">GetSeqElem</a></h3>
<p class="Blurb">Returns pointer to sequence element by its index</p>
<pre>
char* cvGetSeqElem( CvSeq* seq, int index, CvSeqBlock** block=0 );
#define CV_GET_SEQ_ELEM( TYPE, seq, index )  (TYPE*)cvGetSeqElem( (CvSeq*)(seq), (index), 0 )
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>index<dd>Index of element.
<dt>block<dd>Optional output parameter. If it is not <em>NULL</em>, the pointer to
the sequence block containing the requested element is stored in this location.
</dl><p>
The function <a href="#decl_cvGetSeqElem">cvGetSeqElem</a> finds the element with the given index in the sequence
and returns the pointer to it. In addition, the function can return the pointer
to the sequence block that contains the element. If the element is not found,
the function returns 0. The function supports negative indices, where -1 stands
for the last sequence element, -2 stands for the one before last, etc. If the
sequence is most likely to consist of a single sequence block or the desired
element is likely to be located in the first block, then the macro
<em>CV_GET_SEQ_ELEM( elemType, seq, index )</em> should be used, where the parameter
<em>elemType</em> is the type of sequence elements ( <a href="#decl_CvPoint">CvPoint</a> for example), the parameter
<em>seq</em> is a sequence, and the parameter <em>index</em> is the index of the desired element.
The macro checks first whether the desired element belongs to the first block of
the sequence and, if so, returns the element, otherwise the macro calls the main
function <em>GetSeqElem</em>. Negative indices always cause the <a href="#decl_cvGetSeqElem">cvGetSeqElem</a> call.
The function has O(1) time complexity assuming that number of blocks is much smaller than the
number of elements.</p>


<hr><h3><a name="decl_cvSeqElemIdx">SeqElemIdx</a></h3>
<p class="Blurb">Returns index of concrete sequence element</p>
<pre>
int cvSeqElemIdx( CvSeq* seq, void* element, CvSeqBlock** block=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>element<dd>Pointer to the element within the sequence.
<dt>block<dd>Optional argument. If the pointer is not <em>NULL</em>, the address of the
sequence block that contains the element is stored in this location.
</dl><p>
The function <a href="#decl_cvSeqElemIdx">cvSeqElemIdx</a> returns the index of a sequence element or a negative
number if the element is not found.</p>


<hr><h3><a name="decl_CvtSeqToArray">CvtSeqToArray</a></h3>
<p class="Blurb">Copies sequence to one continuous block of memory</p>
<pre>
void* cvCvtSeqToArray( CvSeq* seq, void* array, CvSlice slice=CV_WHOLE_SEQ );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>array<dd>Pointer to the destination array that must fit all the sequence elements.
<dt>slice<dd>The sequence part to copy to the array.
</dl><p>
The function <a href="#decl_cvCvtSeqToArray">cvCvtSeqToArray</a> copies the entire sequence or subsequence to the
specified buffer and returns the pointer to the buffer.</p>


<hr><h3><a name="decl_cvMakeSeqHeaderForArray">MakeSeqHeaderForArray</a></h3>
<p class="Blurb">Constructs sequence from array</p>
<pre>
void cvMakeSeqHeaderForArray( int seqType, int headerSize, int elemSize,
                              void* array, int total,
                              CvSeq* sequence, CvSeqBlock* block );
</pre><p><dl>
<dt>seqType<dd>Type of the created sequence.
<dt>headerSize<dd>Size of the header of the sequence. Parameter sequence must point to
the structure of that size or greater size.
<dt>elemSize<dd>Size of the sequence element.
<dt>array<dd>Pointer to the array that makes up the sequence.
<dt>total<dd>Total number of elements in the sequence. The number of array elements
must be equal to the value of this parameter.
<dt>sequence<dd>Pointer to the local variable that is used as the sequence header.
<dt>block<dd>Pointer to the local variable that is the header of the single sequence
block.
</dl><p>
The function <a href="#decl_cvMakeSeqHeaderForArray">cvMakeSeqHeaderForArray</a> initializes sequence header for array.
The sequence header as well as the sequence block are allocated by the user (for example, on stack).
No data is copied by the function. The resultant sequence will consists of a single block and have
NULL storage pointer, thus, it is possible to read its elements, but the attempts to
add elements to the sequence will raise an error in most cases.</p>


<hr><h3><a name="decl_cvSeqSlice">SeqSlice</a></h3>
<p class="Blurb">Makes separate header for the sequence slice</p>
<pre>
CvSeq* cvSeqSlice( CvSeq* seq, CvSlice slice=CV_WHOLE_SEQ,
                   CvMemStorage* storage=0, int copyData=0 );

cvCloneSeq(seq[,storage]) ~ cvSeqSlice(seq,CV_WHOLE_SEQ,storage,1)
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>slice<dd>The part of the sequence to extract.
<dt>storage<dd>The destination storage to keep the new sequence header and the copied data if any.
               If it is NULL, the function uses the storage containing the input sequence.
<dt>copyData<dd>The flag that indicates whether to copy the elements of the extracted slice
                 (<em>copyData</em>!=0) or not (<em>copyData</em>=0)
</dl><p>
The function <a href="#decl_cvSeqSlice">cvSeqSlice</a> creates another sequence and either makes it share the elements
of the specified slice with the original sequence or creates another copy of the slice.
So if one needs to process a part of sequence but the processing function does not have a slice parameter,
the required sequence slice may be represented as a separate sequence using this function.
Another purpose of the function is to make a copy of entire sequence that is done
by <a href="#decl_cvCloneSeq">cvCloneSeq</a> inline shortcut to <a href="#decl_cvSeqSlice">cvSeqSlice</a></p>


<hr><h3><a name="decl_cvSeqRemoveSlice">SeqRemoveSlice</a></h3>
<p class="Blurb">Removes sequence slice</p>
<pre>
void cvSeqRemoveSlice( CvSeq* seq, CvSlice slice );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>slice<dd>The part of the sequence to remove.
</dl><p>
The function <a href="#decl_cvSeqRemoveSlice">cvSeqRemoveSlice</a> removes slice from the sequence.</p>


<hr><h3><a name="decl_cvSeqInsertSlice">SeqInsertSlice</a></h3>
<p class="Blurb">Inserts array in the middle of sequence</p>
<pre>
void cvSeqInsertSlice( CvSeq* seq, int beforeIndex, const CvArr* fromArr );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>slice<dd>The part of the sequence to remove.
</dl><p>
The function <a href="#decl_cvSeqInsertSlice">cvSeqInsertSlice</a> inserts all <em>fromArr</em> array elements at
the specified position of the sequence. The array may be matrix or another sequence.</p>


<hr><h3><a name="decl_cvSeqInvert">SeqInvert</a></h3>
<p class="Blurb">Reverses the order of sequence elements</p>
<pre>
void cvSeqInvert( CvSeq* seq );
</pre><p><dl>
<dt>seq<dd>Sequence.
</dl><p>
The function <a href="#decl_cvSeqInvert">cvSeqInvert</a> reverses the sequence in-place - makes the first element go last,
the last element go first etc.</p>


<hr><h3><a name="decl_cvSeqSort">SeqSort</a></h3>
<p class="Blurb">Sorts sequence element using the specified comparison function</p>
<pre>
/* a &lt; b ? -1 : a > b ? 1 : 0 */
typedef int (CV_CDECL* CvCmpFunc)(const void* a, const void* b, void* userdata);

void cvSeqSort( CvSeq* seq, CvCmpFunc func, void* userdata );
</pre><p><dl>
<dt>seq<dd>The sequence to sort
<dt>func<dd>The comparison function that returns negative, zero or positive value depending
            on the elements relation (see the above declaration and the example below) -
            similar function is used by <em>qsort</em> from C runline except that in the latter
            <em>userdata</em> is not used
<dt>userdata<dd>The user parameter passed to the compasion function;
                helps to avoid global variables in some cases.
</dl><p>
The function <a href="#decl_cvSeqSort">cvSeqSort</a> sorts the sequence in-place using the specified criteria.
Below is the example of the function use:</p>
<pre>
/* Sort 2d points in top-to-bottom left-to-right order */
static int cmp_func( const void* _a, const void* _b, void* userdata )
{
    CvPoint* a = (CvPoint*)_a;
    CvPoint* b = (CvPoint*)_b;
    int y_diff = a->y - b->y;
    int x_diff = a->x - b->x;
    return y_diff ? y_diff : x_diff;
}

...

CvMemStorage* storage = cvCreateMemStorage(0);
CvSeq* seq = cvCreateSeq( CV_32SC2, sizeof(CvSeq), sizeof(CvPoint), storage );
int i;

for( i = 0; i &lt; 10; i++ )
{
    CvPoint pt;
    pt.x = rand() % 1000;
    pt.y = rand() % 1000;
    cvSeqPush( seq, &pt );
}

cvSeqSort( seq, cmp_func, 0 /* userdata is not used here */ );

/* print out the sorted sequence */
for( i = 0; i &lt; seq->total; i++ )
{
    CvPoint* pt = (CvPoint*)cvSeqElem( seq, i );
    printf( "(%d,%d)\n", pt->x, pt->y );
}

cvReleaseMemStorage( &storage );
</pre>



<hr><h3><a name="decl_cvStartAppendToSeq">StartAppendToSeq</a></h3>
<p class="Blurb">Initializes process of writing to sequence</p>
<pre>
void cvStartAppendToSeq( CvSeq* seq, CvSeqWriter* writer );
</pre><p><dl>
<dt>seq<dd>Pointer to the sequence.
<dt>writer<dd>Writer state; initialized by the function.
</dl><p>
The function <a href="#decl_cvStartAppendToSeq">cvStartAppendToSeq</a> initializes the writer to write to the sequence.
Written elements are added to the end of the sequence by <em>CV_WRITE_SEQ_ELEM( written_elem, writer )</em> macro.
Note that during the writing process other operations on the sequence may yield incorrect result or
even corrupt the sequence (see description of <a href="#decl_cvFlushSeqWriter">cvFlushSeqWriter</a> that helps to avoid
some of that difficulties).</p>


<hr><h3><a name="decl_cvStartWriteSeq">StartWriteSeq</a></h3>
<p class="Blurb">Creates new sequence and initializes writer for it</p>
<pre>
void cvStartWriteSeq( int seqFlags, int headerSize, int elemSize,
                      CvMemStorage* storage, CvSeqWriter* writer );
</pre><p><dl>
<dt>seqFlags<dd>Flags of the created sequence. If the sequence is not passed to any
function working with a specific type of sequences, the sequence value may be
equal to 0, otherwise the appropriate type must be selected from the list of
predefined sequence types.
<dt>headerSize<dd>Size of the sequence header. The parameter value may not be less than
<em>sizeof(CvSeq)</em>. If a certain type or extension is specified, it must fit the
base type header.
<dt>elemSize<dd>Size of the sequence elements in bytes; must be consistent with the
sequence type. For example, if the sequence of points is created (element type
<em>CV_SEQ_ELTYPE_POINT</em> ), then the parameter elemSize must be equal to
<em>sizeof(CvPoint)</em>.
<dt>storage<dd>Sequence location.
<dt>writer<dd>Writer state; initialized by the function.
</dl><p>
The function <a href="#decl_cvStartWriteSeq">cvStartWriteSeq</a> is a composition of <a href="#decl_cvCreateSeq">cvCreateSeq</a> and <a href="#decl_cvStartAppendToSeq">cvStartAppendToSeq</a>.
The pointer to the created sequence is stored at <em>writer->seq</em> and is also returned
by <a href="#decl_cvEndWriteSeq">cvEndWriteSeq</a> function that should be called in the end.</p>


<hr><h3><a name="decl_cvEndWriteSeq">EndWriteSeq</a></h3>
<p class="Blurb">Finishes process of writing sequence</p>
<pre>
CvSeq* cvEndWriteSeq( CvSeqWriter* writer );
</pre><p><dl>
<dt>writer<dd>Writer state
</dl><p>
The function <a href="#decl_cvEndWriteSeq">cvEndWriteSeq</a> finishes the writing process and returns the pointer to
the written sequence. The function also truncates the last incomplete sequence block to
return the remaining part of the block to the memory storage. After that the sequence
can be read and modified safely.</p>


<hr><h3><a name="decl_cvFlushSeqWriter">FlushSeqWriter</a></h3>
<p class="Blurb">Updates sequence headers from the writer state</p>
<pre>
void cvFlushSeqWriter( CvSeqWriter* writer );
</pre><p><dl>
<dt>writer<dd>Writer state
</dl><p>
The function <a href="#decl_cvFlushSeqWriter">cvFlushSeqWriter</a> is intended to enable the user to read sequence
elements, whenever required, during the writing process, e.g., in order to check
specific conditions. The function updates the sequence headers to make reading
from the sequence possible. The writer is not closed, however, so that the
writing process can be continued any time. In some algorithm requires often flush'es,
consider using <a href="#decl_cvSeqPush">cvSeqPush</a> instead.</p>


<hr><h3><a name="decl_cvStartReadSeq">StartReadSeq</a></h3>
<p class="Blurb">Initializes process of sequential reading from sequence</p>
<pre>
void cvStartReadSeq( CvSeq* seq, CvSeqReader* reader, int reverse=0 );
</pre><p><dl>
<dt>seq<dd>Sequence.
<dt>reader<dd>Reader state; initialized by the function.
<dt>reverse<dd>Determines the direction of the sequence traversal. If <em>reverse</em> is 0,
the reader is positioned at the first sequence element, otherwise it is positioned at the last
element.
</dl><p>
The function <a href="#decl_cvStartReadSeq">cvStartReadSeq</a> initializes the reader state. After that all the
sequence elements from the first down to the last one can be read by subsequent
calls of the macro <em>CV_READ_SEQ_ELEM( read_elem, reader )</em> in case of forward reading
and by using <em>CV_REV_READ_SEQ_ELEM( read_elem, reader )</em> in case of reversed reading.
Both macros put the sequence element to <em>read_elem</em> and move the
reading pointer toward the next element.
A circular structure of sequence blocks is used for the reading process, that
is, after the last element has been read by the macro <em>CV_READ_SEQ_ELEM</em>, the
first element is read when the macro is called again. The same applies to
<em>CV_REV_READ_SEQ_ELEM </em>. There is no function to finish the reading process,
since it neither changes the sequence nor creates any temporary buffers. The reader
field <em>ptr</em> points to the current element of the sequence that is to be read
next. The code below demonstrates how to use sequence writer and reader.</p>
<pre>
CvMemStorage* storage = cvCreateMemStorage(0);
CvSeq* seq = cvCreateSeq( CV_32SC1, sizeof(CvSeq), sizeof(int), storage );
CvSeqWriter writer;
CvSeqReader reader;
int i;

cvStartAppendToSeq( seq, &writer );
for( i = 0; i &lt; 10; i++ )
{
    int val = rand()%100;
    CV_WRITE_SEQ_ELEM( val, writer );
    printf("%d is written\n", val );
}
cvEndWriteSeq( &writer );

cvStartReadSeq( seq, &reader, 0 );
for( i = 0; i &lt; seq->total; i++ )
{
    int val;
    CV_READ_SEQ_ELEM( val, reader );
    printf("%d is read\n", val );
}
...

cvReleaseStorage( &storage );
</pre>


<hr><h3><a name="decl_cvGetSeqReaderPos">GetSeqReaderPos</a></h3>
<p class="Blurb">Returns the current reader position</p>
<pre>
int cvGetSeqReaderPos( CvSeqReader* reader );
</pre><p><dl>
<dt>reader<dd>Reader state.
</dl><p>
The function <a href="#decl_cvGetSeqReaderPos">cvGetSeqReaderPos</a> returns the current reader position
(within 0 ... <em>reader->seq->total</em> - 1).</p>


<hr><h3><a name="decl_cvSetSeqReaderPos">SetSeqReaderPos</a></h3>
<p class="Blurb">Moves the reader to specified position</p>
<pre>
void cvSetSeqReaderPos( CvSeqReader* reader, int index, int is_relative=0 );
</pre><p><dl>

<dt>reader<dd>Reader state.
<dt>index<dd>The destination position. If the positioning mode is used (see the next parameter)
             the actual position will be <em>index</em> mod <em>reader->seq->total</em>.
<dt>is_relative<dd>If it is not zero, then <em>index</em> is a relative to the current position.
</dl><p>
The function <a href="#decl_cvSetSeqReaderPos">cvSetSeqReaderPos</a> moves the read position to the absolute position or
relative to the current position.
</p>


<hr><h2><a name="ch1_sets">Sets</a></h2>

<hr><h3><a name="decl_CvSet">CvSet</a></h3>
<p class="Blurb">Collection of nodes</p>
<pre>
    typedef struct CvSetElem
    {
        int flags; /* it is negative if the node is free and zero or positive otherwise */
        struct CvSetElem* next_free; /* if the node is free, the field is a
                                        pointer to next free node */
    }
    CvSetElem;

    #define CV_SET_FIELDS()    \
        CV_SEQUENCE_FIELDS()   /* inherits from <a href="#decl_CvSeq">CvSeq</a> */ \
        struct CvSetElem* free_elems; /* list of free nodes */

    typedef struct CvSet
    {
        CV_SET_FIELDS()
    } CvSet;
</pre>
<p>
The structure <a href="#decl_CvSet">CvSet</a> is a base for OpenCV sparse data structures.</p>
<p>As follows from the above declaration <a href="#decl_CvSet">CvSet</a> inherits from <a href="#decl_CvSeq">CvSeq</a>
and it adds <em>free_elems</em> field it to, which is a list of free nodes.
Every set node, whether free or not, is the element of the underlying sequence.
While there is no restrictions on elements of dense sequences, the set (and derived structures)
elements must start with integer field and be able to fit CvSetElem structure, because
these two fields (integer followed by the pointer) are required for organization of node set with
the list of free nodes. If a node is free, <em>flags</em> field is negative (the most-significant
bit, or MSB, of the field is set), and <em>next_free</em>
points to the next free node (the first free node is referenced by <em>free_elems</em> field of
<a href="#decl_CvSet">CvSet</a>). And if a node is occupied, <em>flags</em> field is positive and contains the node index
that may be retrieved using (set_elem->flags & CV_SET_ELEM_IDX_MASK) expression,
the rest of the node content is determined by the user. In particular, the occupied nodes
are not linked as the free nodes are, so the second field can be used for such a link as well as
for some different purpose. The macro <em>CV_IS_SET_ELEM(set_elem_ptr)</em>
can be used to determined whether the specified node is occupied or not.</p>
<p>
Initially the set and the list are empty. When a new node is requiested from the set,
it is taken from the list of free nodes, which is updated then. If the list appears to be empty,
a new sequence block is allocated and all the nodes within the block are joined in the list of free
nodes. Thus, <em>total</em> field of the set is the total number of nodes both occupied and free.
When an occupied node is released, it is added to the list of free nodes. The node released last
will be occupied first.</p>
<p>In OpenCV <a href="#decl_CvSet">CvSet</a> is used for representing graphs (<a href="#decl_CvGraph">CvGraph</a>),
sparse multi-dimensional arrays (<a href="#decl_CvSparseMat">CvSparseMat</a>), planar subdivisions (<a href="#decl_CvSubdiv2D">CvSubdiv2D</a>) etc.</p>


<hr><h3><a name="decl_cvCreateSet">CreateSet</a></h3>
<p class="Blurb">Creates empty set</p>
<pre>
CvSet* cvCreateSet( int setFlags, int headerSize,
                    int elemSize, CvMemStorage* storage );
</pre><p><dl>
<dt>setFlags<dd>Type of the created set.
<dt>headerSize<dd>Set header size; may not be less than <em>sizeof(CvSet)</em>.
<dt>elemSize<dd>Set element size; may not be less than <a href="#decl_CvSetElem">CvSetElem</a>.
<dt>storage<dd>Container for the set.
</dl><p>
The function <a href="#decl_cvCreateSet">cvCreateSet</a> creates an empty set with a specified header size and element size, and
returns the pointer to the set. The function is just a thin layer on top of <a href="#decl_cvCreateSeq">cvCreateSeq</a>.</p>


<hr><h3><a name="decl_cvSetAdd">SetAdd</a></h3>
<p class="Blurb">Occupies a node in the set</p>
<pre>
int cvSetAdd( CvSet* set, void* elem, void** insertedElem=0 );
</pre><p><dl>
<dt>set<dd>Set.
<dt>elem<dd>Optional input argument, inserted element. If not NULL, the function
copies the data to the allocated node (The MSB of the first integer field is cleared after copying).
<dt>insertedElem<dd>Optional output argument; the pointer to the allocated cell.
</dl><p>
The function <a href="#decl_cvSetAdd">cvSetAdd</a> allocates a new node, optionally copies input element data
to it, and returns the pointer and the index to the node. The index value is
taken from the lower bits of <em>flags</em> field of the node. The function has O(1) complexity,
however there exists a faster function for allocating set nodes (see <a href="#decl_cvSetNew">cvSetNew</a>).
</p>


<hr><h3><a name="decl_cvSetRemove">SetRemove</a></h3>
<p class="Blurb">Removes element from set</p>
<pre>
void cvSetRemove( CvSet* set, int index );
</pre><p><dl>
<dt>set<dd>Set.
<dt>index<dd>Index of the removed element.
</dl><p>
The function <a href="#decl_cvSetRemove">cvSetRemove</a> removes an element with a specified index from the set.
If the node at the specified location is not occupied the function does nothing.
The function has O(1) complexity, however, <a href="#decl_cvSetRemoveByPtr">cvSetRemoveByPtr</a> provides yet
faster way to remove a set element if it is located already.</p>


<hr><h3><a name="decl_cvSetNew">SetNew</a></h3>
<p class="Blurb">Adds element to set (fast variant)</p>
<pre>
CvSetElem* cvSetNew( CvSet* set );
</pre><p><dl>
<dt>set<dd>Set.
</dl><p>
The function <a href="#decl_cvSetNew">cvSetNew</a> is inline light-weight variant of <a href="#decl_cvSetAdd">cvSetAdd</a>.
It occupies a new node and returns pointer to it rather than index.</p>


<hr><h3><a name="decl_cvSetRemoveByPtr">SetRemoveByPtr</a></h3>
<p class="Blurb">Removes set element given its pointer</p>
<pre>
void cvSetRemoveByPtr( CvSet* set, void* elem );
</pre><p><dl>
<dt>set<dd>Set.
<dt>elem<dd>Removed element.
</dl><p>
The function <a href="#decl_cvSetRemoveByPtr">cvSetRemoveByPtr</a> is inline light-weight variant of <a href="#decl_cvSetRemove">cvSetRemove</a>
that takes element pointer.
The function does not check whether the node is occupied or not - the user should take care of it.</p>


<hr><h3><a name="decl_cvGetSetElem">GetSetElem</a></h3>
<p class="Blurb">Finds set element by its index</p>
<pre>
CvSetElem* cvGetSetElem( CvSet* set, int index );
</pre><p><dl>
<dt>set<dd>Set.
<dt>index<dd>Index of the set element within a sequence.
</dl><p>
The function <a href="#decl_cvGetSetElem">cvGetSetElem</a> finds a set element by index. The function returns the
pointer to it or 0 if the index is invalid or the corresponding node is free.
The function supports negative indices as it uses <a href="#decl_cvGetSeqElem">cvGetSeqElem</a> to locate the node.</p>
</p>


<hr><h3><a name="decl_cvClearSet">ClearSet</a></h3>
<p class="Blurb">Clears set</p>
<pre>
void cvClearSet( CvSet* set );
</pre><p><dl>
<dt>set<dd>Cleared set.
</dl><p>
The function <a href="#decl_cvClearSet">cvClearSet</a> removes all elements from set. It has O(1) time complexity.</p>


<hr><h2><a name="ch1_graphs">Graphs</a></h2>

<hr><h3><a name="decl_CvGraph">CvGraph</a></h3>
<p class="Blurb">Oriented or unoriented weigted graph</p>
<pre>
    #define CV_GRAPH_VERTEX_FIELDS()    \
        int flags; /* vertex flags */   \
        struct CvGraphEdge* first; /* the first incident edge */

    typedef struct CvGraphVtx
    {
        CV_GRAPH_VERTEX_FIELDS()
    }
    CvGraphVtx;

    #define CV_GRAPH_EDGE_FIELDS()      \
        int flags; /* edge flags */     \
        float weight; /* edge weight */ \
        struct CvGraphEdge* next[2]; /* the next edges in the incidence lists for staring (0) */ \
                                     /* and ending (1) vertices */ \
        struct CvGraphVtx* vtx[2]; /* the starting (0) and ending (1) vertices */

    typedef struct CvGraphEdge
    {
        CV_GRAPH_EDGE_FIELDS()
    }
    CvGraphEdge;

    #define  CV_GRAPH_FIELDS()                  \
        CV_SET_FIELDS() /* set of vertices */   \
        CvSet* edges;   /* set of edges */

    typedef struct CvGraph
    {
        CV_GRAPH_FIELDS()
    }
    CvGraph;

</pre>
<p>
The structure <a href="#decl_CvGraph">CvGraph</a> is a base for graphs used in OpenCV.</p>
<p>Graph structure inherits from <a href="#decl_CvSet">CvSet</a> - this part describes common graph properties and
the graph vertices, and contains another set as a member - this part describes the graph edges.</p>
<p>The vertex, edge and the graph header structures are declared using the same technique as other
extendible OpenCV structures - via macros, that simplifies extension and customization of the structures.
While the vertex and edge structures do not inherit from <a href="#decl_CvSetElem">CvSetElem</a> explicitly, they satisfy
both conditions on the set elements - have an integer field in the beginning and fit CvSetElem structure.
The <em>flags</em> fields are used as for indicating occupied vertices and edges as well as
for other purposes, for example, for graph traversal (see <a href="#decl_cvStartScanGraph">cvStartScanGraph</a> et al.), so
it is better not to use them directly.</p>
<p>The graph is represented as a set of edges each of whose has the list of incident edges. The incidence
lists for different vertices are interleaved to avoid information duplication as much as posssible.</p>
<p>The graph may be oriented or unoriented. In the latter case there is no distiction between edge
connecting vertex A with vertex B and the edge connecting vertex B with vertex A - only one of them
can exist in the graph at the same moment and it represents both &lt;A, B&gt; and &lt;B, A&gt; edges..</p>



<hr><h3><a name="decl_cvCreateGraph">CreateGraph</a></h3>
<p class="Blurb">Creates empty graph</p>
<pre>
CvGraph* cvCreateGraph( int graphFlags, int headerSize, int vertexSize,
                        int edgeSize, CvStorage* storage );
</pre><p><dl>
<dt>graphFlags<dd>Type of the created graph. Usually, it is either <em>CV_SEQ_KIND_GRAPH</em>
for generic unoriented graphs and <em>CV_SEQ_KIND_GRAPH | CV_GRAPH_FLAG_ORIENTED</em> for generic oriented graphs.
<dt>headerSize<dd>Graph header size; may not be less than <em>sizeof(CvGraph).</em>
<dt>vertexSize<dd>Graph vertex size; the custom vertex structure must start with <a href="#decl_CvGraphVtx">CvGraphVtx</a>
                  (use <em>CV_GRAPH_VERTEX_FIELDS()</em>)
<dt>edgeSize<dd>Graph edge size; the custom edge structure must start with <a href="#decl_CvGraphEdge">CvGraphEdge</a>
                (use <em>CV_GRAPH_EDGE_FIELDS()</em>)
<dt>storage<dd>The graph container.
</dl><p>
The function <a href="#decl_cvCreateGraph">cvCreateGraph</a> creates an empty graph and returns pointer to it.</p>


<hr><h3><a name="decl_cvGraphAddVtx">GraphAddVtx</a></h3>
<p class="Blurb">Adds vertex to graph</p>
<pre>
int cvGraphAddVtx( CvGraph* graph, CvGraphVtx* vtx,
                   CvGraphVtx** insertedVtx=0 );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtx<dd>Optional input argument used to initialize the added vertex (only user-defined fields
beyond <em>sizeof(CvGraphVtx)</em> are copied).
<dt>insertedVtx<dd>Optional output argument. If not <em>NULL</em>, the address of the new
vertex is written there.
</dl><p>
The function <a href="#decl_cvGraphAddVtx">cvGraphAddVtx</a> adds a vertex to the graph and returns the vertex
index.</p>


<hr><h3><a name="decl_cvGraphRemoveVtx">GraphRemoveVtx</a></h3>
<p class="Blurb">Removes vertex from graph</p>
<pre>
void cvGraphRemoveVtx( CvGraph* graph, int vtxIdx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtxIdx<dd>Index of the removed vertex.
</dl><p>
The function <a href="#decl_cvGraphRemoveAddVtx">cvGraphRemoveAddVtx</a> removes a vertex from the graph together with all
the edges incident to it. The function reports an error, if the input vertex does
not belong to the graph.</p>


<hr><h3><a name="decl_cvGraphRemoveVtxByPtr">GraphRemoveVtxByPtr</a></h3>
<p class="Blurb">Removes vertex from graph</p>
<pre>
void cvGraphRemoveVtxByPtr( CvGraph* graph, CvGraphVtx* vtx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtx<dd>Pointer to the removed vertex.
</dl><p>
The function <a href="#decl_cvGraphRemoveVtxByPtr">cvGraphRemoveVtxByPtr</a> removes a vertex from the graph together with
all the edges incident to it. The function reports an error, if the vertex does not belong to the graph.</p>


<hr><h3><a name="decl_cvGetGraphVtx">GetGraphVtx</a></h3>
<p class="Blurb">Finds graph vertex by index</p>
<pre>
CvGraphVtx* cvGetGraphVtx( CvGraph* graph, int vtxIdx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtxIdx<dd>Index of the vertex.
</dl><p>
The function <a href="#decl_cvGetGraphVtx">cvGetGraphVtx</a> finds the graph vertex by index and returns the pointer
to it or NULL if the vertex does not belong to the graph.</p>


<hr><h3><a name="decl_cvGraphVtxIdx">GraphVtxIdx</a></h3>
<p class="Blurb">Returns index of graph vertex</p>
<pre>
int cvGraphVtxIdx( CvGraph* graph, CvGraphVtx* vtx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtx<dd>Pointer to the graph vertex.
</dl><p>
The function <a href="#decl_cvGraphVtxIdx">cvGraphVtxIdx</a> returns index of the graph vertex.</p>


<hr><h3><a name="decl_cvGraphAddEdge">GraphAddEdge</a></h3>
<p class="Blurb">Adds edge to graph</p>
<pre>
int cvGraphAddEdge( CvGraph* graph, int startIdx, int endIdx,
                    CvGraphEdge* edge, CvGraphEdge** insertedEdge=0 );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startIdx<dd>Index of the starting vertex of the edge.
<dt>endIdx<dd>Index of the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
<dt>edge<dd>Optional input parameter, initialization data for the edge.
<dt>insertedEdge<dd>Optional output parameter to contain the address of the inserted
edge.
</dl><p>
The function <a href="#decl_cvGraphAddEdge">cvGraphAddEdge</a> connects two specified vertices.
The function returns 1 if the edge has been added successfully, 0 if the edge connecting
the two vertices exists already and -1 if either of the vertices was not found, the starting and
the ending vertex are the same or there is some other critical situation. In the latter case
(i.e. when the result is negative) the function also reports an error by default.</p>


<hr><h3><a name="decl_cvGraphAddEdgeByPtr">GraphAddEdgeByPtr</a></h3>
<p class="Blurb">Adds edge to graph</p>
<pre>
int cvGraphAddEdgeByPtr( CvGraph* graph, CvGraphVtx* startVtx, CvGraphVtx* endVtx,
                         CvGraphEdge* edge, CvGraphEdge** insertedEdge=0 );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startVtx<dd>Pointer to the starting vertex of the edge.
<dt>endVtx<dd>Pointer to the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
<dt>edge<dd>Optional input parameter, initialization data for the edge.
<dt>insertedEdge<dd>Optional output parameter to contain the address of the inserted
edge within the edge set.
</dl><p>
The function <a href="#decl_cvGraphAddEdge">cvGraphAddEdge</a> connects two specified vertices.
The function returns 1 if the edge has been added successfully, 0 if the edge connecting
the two vertices exists already and -1 if either of the vertices was not found, the starting and
the ending vertex are the same or there is some other critical situation. In the latter case
(i.e. when the result is negative) the function also reports an error by default.</p>


<hr><h3><a name="decl_cvGraphRemoveEdge">GraphRemoveEdge</a></h3>
<p class="Blurb">Removes edge from graph</p>
<pre>
void cvGraphRemoveEdge( CvGraph* graph, int startIdx, int endIdx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startIdx<dd>Index of the starting vertex of the edge.
<dt>endIdx<dd>Index of the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
</dl><p>
The function <a href="#decl_cvGraphRemoveEdge">cvGraphRemoveEdge</a> removes the edge connecting two specified vertices.
If the vertices are not connected [in that order], the function does nothing.
</p>


<hr><h3><a name="decl_cvGraphRemoveEdgeByPtr">GraphRemoveEdgeByPtr</a></h3>
<p class="Blurb">Removes edge from graph</p>
<pre>
void cvGraphRemoveEdgeByPtr( CvGraph* graph, CvGraphVtx* startVtx, CvGraphVtx* endVtx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startVtx<dd>Pointer to the starting vertex of the edge.
<dt>endVtx<dd>Pointer to the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
</dl><p>
The function <a href="#decl_cvGraphRemoveEdgeByPtr">cvGraphRemoveEdgeByPtr</a> removes the edge connecting two specified vertices.
If the vertices are not connected [in that order], the function does nothing.</p>


<hr><h3><a name="decl_cvFindGraphEdge">FindGraphEdge</a></h3>
<p class="Blurb">Finds edge in graph</p>
<pre>
CvGraphEdge* cvFindGraphEdge( CvGraph* graph, int startIdx, int endIdx );
#define cvGraphFindEdge cvFindGraphEdge
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startIdx<dd>Index of the starting vertex of the edge.
<dt>endIdx<dd>Index of the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
</dl><p>
The function <a href="#decl_cvFindGraphEdge">cvFindGraphEdge</a> finds the graph edge connecting two specified vertices
and returns pointer to it or NULL if the edge does not exists.</p>


<hr><h3><a name="decl_cvFindGraphEdgeByPtr">FindGraphEdgeByPtr</a></h3>
<p class="Blurb">Finds edge in graph</p>
<pre>
CvGraphEdge* cvFindGraphEdgeByPtr( CvGraph* graph, CvGraphVtx* startVtx, CvGraphVtx* endVtx );
#define cvGraphFindEdgeByPtr cvFindGraphEdgeByPtr
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>startVtx<dd>Pointer to the starting vertex of the edge.
<dt>endVtx<dd>Pointer to the ending vertex of the edge. For unoriented graph the order of the vertex
parameters does not matter.
</dl><p>
The function <a href="#decl_cvFindGraphEdge">cvFindGraphEdge</a> finds the graph edge connecting two specified vertices
and returns pointer to it or NULL if the edge does not exists.</p>


<hr><h3><a name="decl_cvGraphEdgeIdx">GraphEdgeIdx</a></h3>
<p class="Blurb">Returns index of graph edge</p>
<pre>
int cvGraphEdgeIdx( CvGraph* graph, CvGraphEdge* edge );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>edge<dd>Pointer to the graph edge.
</dl><p>
The function <a href="#decl_cvGraphEdgeIdx">cvGraphEdgeIdx</a> returns index of the graph edge.</p>


<hr><h3><a name="decl_cvGraphVtxDegree">GraphVtxDegree</a></h3>
<p class="Blurb">Counts edges indicent to the vertex</p>
<pre>
int cvGraphVtxDegree( CvGraph* graph, int vtxIdx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtx<dd>Index of the graph vertex.
</dl><p>
The function <a href="#decl_cvGraphVtxDegree">cvGraphVtxDegree</a> returns the number of edges
incident to the specified vertex, both incoming and outcoming.
To count the edges, the following code is used:</p>
<pre>
    CvGraphEdge* edge = vertex->first; int count = 0;
    while( edge )
    {
        edge = CV_NEXT_GRAPH_EDGE( edge, vertex );
        count++;
    }
</pre>
<p>The macro <em>CV_NEXT_GRAPH_EDGE( edge, vertex )</em> returns the edge incident to <em>vertex</em>
that follows after <em>edge</em>.</p>


<hr><h3><a name="decl_cvGraphVtxDegreeByPtr">GraphVtxDegreeByPtr</a></h3>
<p class="Blurb">Finds edge in graph</p>
<pre>
int cvGraphVtxDegreeByPtr( CvGraph* graph, CvGraphVtx* vtx );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>vtx<dd>Pointer to the graph vertex.
</dl><p>
The function <a href="#decl_cvGraphVtxDegree">cvGraphVtxDegree</a> returns the number of edges
incident to the specified vertex, both incoming and outcoming.</p>


<hr><h3><a name="decl_cvClearGraph">ClearGraph</a></h3>
<p class="Blurb">Clears graph</p>
<pre>
void cvClearGraph( CvGraph* graph );
</pre><p><dl>
<dt>graph<dd>Graph.
</dl><p>
The function <a href="#decl_cvClearGraph">cvClearGraph</a> removes all vertices and edges from the graph.
The function has O(1) time complexity.</p>


<hr><h3><a name="decl_cvCloneGraph">CloneGraph</a></h3>
<p class="Blurb">Clone graph</p>
<pre>
CvGraph* cvCloneGraph( const CvGraph* graph, CvMemStorage* storage );
</pre><p><dl>
<dt>graph<dd>The graph to copy.
<dt>storage<dd>Container for the copy.
</dl><p>
The function <a href="#decl_cvCloneGraph">cvCloneGraph</a> creates full copy of the graph. If the graph vertices
or edges have pointers to some external data, it still be shared between the copies.
The vertex and edge indices in the new graph may be different from the original, because
the function defragments the vertex and edge sets.</p>


<hr><h3><a name="decl_CvGraphScanner">CvGraphScanner</a></h3>
<p class="Blurb">Graph traversal state</p>
<pre>
    typedef struct CvGraphScanner
    {
        CvGraphVtx* vtx;       /* current graph vertex (or current edge origin) */
        CvGraphVtx* dst;       /* current graph edge destination vertex */
        CvGraphEdge* edge;     /* current edge */

        CvGraph* graph;        /* the graph */
        CvSeq*   stack;        /* the graph vertex stack */
        int      index;        /* the lower bound of certainly visited vertices */
        int      mask;         /* event mask */
    }
    CvGraphScanner;
</pre>
<p>The structure <a href="#decl_CvGraphScanner">CvGraphScanner</a> is used for depth-first graph traversal.
See discussion of the functions below.</p>


<hr><h3><a name="decl_cvStartScanGraph">StartScanGraph</a></h3>
<p class="Blurb">Initializes graph traverser state</p>
<pre>
void cvStartScanGraph( CvGraph* graph, CvGraphScanner* scanner,
                       CvGraphVtx* vtx=0, int mask=CV_GRAPH_ALL_ITEMS );
</pre><p><dl>
<dt>graph<dd>Graph.
<dt>scanner<dd>Graph traversal state. It is initialized by the function.
<dt>vtx<dd>Initial vertex to start from.
<dt>mask<dd>Event mask indicating which events are interesting to the user (where <a href="#decl_cvNextGraphItem">cvNextGraphItem</a>
            function returns control to the user)
            It can be <em>CV_GRAPH_ALL_ITEMS</em> (all events are interesting)
            or combination of the following flags:<ul>
            <li>CV_GRAPH_VERTEX - stop at the graph vertices visited for the first time<br>
            <li>CV_GRAPH_TREE_EDGE - stop at tree edges (<em>tree edge</em> is the edge connecting the last visited vertex and
                                 the vertex to be visited next)<br>
            <li>CV_GRAPH_BACK_EDGE - stop at back edges (<em>back edge</em> is the edge connecting
                                 the last visited vertex and the vertex that was visited before)<br>
            <li>CV_GRAPH_FORWARD_EDGE - stop at forward edges (<em>forward edge</em> is the edge connecting
                                 the vertex not visited yet and the last visited vertex (in that order).
                                 The <em>forward edges</em> are possible only during oriented graph traversal)<br>
            <li>CV_GRAPH_CROSS_EDGE - stop at cross edges (<em>cross edge</em> is similar to <em>back edge</em> but
                                 the ending vertex belongs to another traversal tree).
                                 The <em>cross edges</em> are also possible only during oriented graphs traversal)<br>
            <li>CV_GRAPH_ANY_EDGE - stop and any edge (<em>tree, back, forward and cross edges</em>)<br>
            <li>CV_GRAPH_NEW_TREE - stop in the beginning of every new traversal tree. When the traversal procedure
                                visits all vertices and edges reachible from the initial vertex (the visited vertices
                                together with tree edges make up a tree), it search for some unvisited vertices
                                in the graph and resumes the traversal process from the vertex.
                                Before starting the new tree (including the initial call of the traversal procedure)
                                it generates <em>CV_GRAPH_NEW_TREE</em> event.<br>
                                For unoriented graphs traversal tree corresponds to a connected component of the graph.<br>
            <li>CV_GRAPH_BACKTRACKING - stop at every already visited vertex during backtracking - returning to visited
                                already visited vertexes of the traversal tree.<br></ul>
</dl><p>
The function <a href="#decl_cvStartScanGraph">cvStartScanGraph</a> initializes graph traverser state. The initialized
structure is used in <a href="#decl_cvNextGraphItem">cvNextGraphItem</a> function - the incremental traversal procedure.</p>


<hr><h3><a name="decl_cvNextGraphItem">NextGraphItem</a></h3>
<p class="Blurb">Makes one or more steps of the graph traversal procedure</p>
<pre>
int cvNextGraphItem( CvGraphScanner* scanner );
</pre><p><dl>
<dt>scanner<dd>Graph traversal state. It is updated by the function.
</dl><p>
The function <a href="#decl_cvNextGraphItem">cvNextGraphItem</a> traverses through the graph until an event interesting to the user
(that is, an event, marked in the <em>mask</em> in <a href="#decl_cvStartScanGraph">cvStartScanGraph</a> call) is met or the traversal
is over. In the first case it returns one of the events,
listed in the description of <em>mask</em> parameter above and with the next call with the same state
it resumes the traversal. In the latter case it returns CV_GRAPH_OVER (-1).
When the event is <em>CV_GRAPH_VERTEX</em>, or <em>CV_GRAPH_BACKTRACKING</em> or <em>CV_GRAPH_NEW_TREE</em>,
the currently observed vertex is stored in <em>scanner->vtx</em>. And if the event is edge-related,
the edge itself is stored at <em>scanner->edge</em>,
the previously visited vertex - at <em>scanner->vtx</em> and the other ending vertex of the edge -
at <em>scanner->dst</em>.</p>


<hr><h3><a name="decl_cvEndScanGraph">EndScanGraph</a></h3>
<p class="Blurb">Finishes graph traversal procedure</p>
<pre>
void cvEndScanGraph( CvGraphScanner* scanner );
</pre><p><dl>
<dt>scanner<dd>Graph traversal state.
</dl><p>
The function <a href="#decl_cvEndScanGraph">cvEndScanGraph</a> finishes graph traversal procedure. It must be called
after CV_GRAPH_OVER event is received or if the traversal is interrupted somewhere before, because
the traverser state contains dynamically allocated structures that need to be released</p>

<hr><h2><a name="ch1_trees">Trees</a></h2>

<hr><h3><a name="decl_CV_TREE_NODE_FIELDS">CV_TREE_NODE_FIELDS</a></h3>
<p class="Blurb">Helper macro for a tree node type declaration</p>
<pre>
#define CV_TREE_NODE_FIELDS(node_type)                          \
    int       flags;         /* micsellaneous flags */          \
    int       header_size;   /* size of sequence header */      \
    struct    node_type* h_prev; /* previous sequence */        \
    struct    node_type* h_next; /* next sequence */            \
    struct    node_type* v_prev; /* 2nd previous sequence */    \
    struct    node_type* v_next; /* 2nd next sequence */
</pre>
<p>The macro <em>CV_TREE_NODE_FIELDS()</em> is used to declare structures
that can be organized into hierarchical strucutures (trees). Although,
it is not shown, the macro is used to declared <a href="#decl_CvSeq">CvSeq</a> - the basic type
for all dynamical structures and <a href="#decl_CvFileNode">CvFileNode</a> - XML node type used
in reading/writing functions (see <em>Persistence</em> section below).
The trees made of nodes declared using this macro can be processed using
the functions described below in this section.</p>


<hr><h3><a name="decl_CvTreeNodeIterator">CvTreeNodeIterator</a></h3>
<p class="Blurb">Opens existing or creates new file storage</p>
<pre>
typedef struct CvTreeNodeIterator
{
    const void* node;
    int level;
    int maxLevel;
}
CvTreeNodeIterator;
</pre>
<p>The structure <a href="#decl_CvTreeNodeIterator">CvTreeNodeIterator</a> is used to traverse trees.
The tree node declaration should start with <em>CV_TREE_NODE_FIELDS(...)</em> macro.</p>


<hr><h3><a name="decl_cvInitTreeNodeIterator">InitTreeNodeIterator</a></h3>
<p class="Blurb">Initializes tree node iterator</p>
<pre>
void cvInitTreeNodeIterator( CvTreeNodeIterator* treeIterator,
                             const void* first, int maxLevel );
</pre><p><dl>
<dt>treeIterator<dd>Tree iterator initialized by the function.
<dt>first<dd>The initial node to start traversing from.
<dt>maxLevel<dd>The maximal level of the tree (<em>first</em> node assumed to be at the first level) to
                traverse up to. For example, 1 means that only nodes at the same level as <em>first</em>
                should be visited, 2 means that the nodes on the same level as <em>first</em> and
                their direct children should be visited etc.
</dl><p>
The function <a href="#decl_cvInitTreeNodeIterator">cvInitTreeNodeIterator</a> initializes tree iterator.
The tree is traversed in depth-first order.</p>


<hr><h3><a name="decl_cvNextTreeNode">NextTreeNode</a></h3>
<p class="Blurb">Returns the currently observed node and moves iterator toward the next node</p>
<pre>
void* cvNextTreeNode( CvTreeNodeIterator* treeIterator );
</pre><p><dl>
<dt>treeIterator<dd>Tree iterator initialized by the function.
</dl><p>
The function <a href="#decl_cvNextTreeNode">cvNextTreeNode</a> returns the currently observed node and then
updates the iterator - moves it toward the next node. In other words, the function behavior
is similar to *p++ expression on usual C pointer or C++ collection iterator.
The function returns NULL if there is no more nodes.</p>


<hr><h3><a name="decl_cvPrevTreeNode">PrevTreeNode</a></h3>
<p class="Blurb">Returns the currently observed node and moves iterator toward the previous node</p>
<pre>
void* cvPrevTreeNode( CvTreeNodeIterator* treeIterator );
</pre><p><dl>
<dt>treeIterator<dd>Tree iterator initialized by the function.
</dl><p>
The function <a href="#decl_cvPrevTreeNode">cvPrevTreeNode</a> returns the currently observed node and then
updates the iterator - moves it toward the previous node. In other words, the function behavior
is similar to *p-- expression on usual C pointer or C++ collection iterator.
The function returns NULL if there is no more nodes.</p>


<hr><h3><a name="decl_cvTreeToNodeSeq">TreeToNodeSeq</a></h3>
<p class="Blurb">Gathers all node pointers to the single sequence</p>
<pre>
CvSeq* cvTreeToNodeSeq( const void* first, int header_size, CvMemStorage* storage );
</pre><p><dl>
<dt>first<dd>The initial tree node.
<dt>header_size<dd>Header size of the created sequence (sizeof(CvSeq) is the most used value).
<dt>storage<dd>Container for the sequence.
</dl><p>
The function <a href="#decl_cvTreeToNodeSeq">cvTreeToNodeSeq</a> puts pointers of all nodes reacheable from <em>first</em>
to the single sequence. The pointers are written subsequently in the depth-first order.</p>


<hr><h3><a name="decl_cvInsertNodeIntoTree">InsertNodeIntoTree</a></h3>
<p class="Blurb">Adds new node to the tree</p>
<pre>
void cvInsertNodeIntoTree( void* node, void* parent, void* frame );
</pre><p><dl>
<dt>node<dd>The inserted node.
<dt>parent<dd>The parent node that is already in the tree.
<dt>frame<dd>The top level node. If <em>parent</em> and <em>frame</em> are the same, <em>v_prev</em>
            field of <em>node</em> is set to NULL rather than <em>parent</em>.
</dl><p>
The function <a href="#decl_cvInsertNodeIntoTree">cvInsertNodeIntoTree</a> adds another node into tree. The function does not
allocate any memory, it can only modify links of the tree nodes.</p>


<hr><h3><a name="decl_cvRemoveNodeFromTree">RemoveNodeFromTree</a></h3>
<p class="Blurb">Removes node from tree</p>
<pre>
void cvRemoveNodeFromTree( void* node, void* frame );
</pre><p><dl>
<dt>node<dd>The removed node.
<dt>frame<dd>The top level node. If <em>node->v_prev = NULL</em> and
            <em>node->h_prev</em> is NULL (i.e. if <em>node</em> is the first child of <em>frame</em>),
            <em>frame->v_next</em> is set to <em>node->h_next</em> (i.e. the first child or frame is changed).
</dl><p>
The function <a href="#decl_cvRemoveNodeFromTree">cvRemoveNodeFromTree</a> removes node from tree. The function does not
deallocate any memory, it can only modify links of the tree nodes.</p>


<hr><h2><a name="ch1_persistence">Persistence (Writing and Reading Structures)</a></h2>

<hr><h3><a name="decl_cvOpenFileStorage">OpenFileStorage</a></h3>
<p class="Blurb">Opens existing or creates new file storage</p>
<pre>
CvFileStorage*  cvOpenFileStorage( const char* filename, CvMemStorage* memstorage, int flags );
</pre><p><dl>
<dt>filename<dd>The storage file name.
<dt>memstorage<dd>Memory storage used for storing temporary data and read dynamic structures.
If it is NULL, the temporary memory storage is created and used.
<dt>flags<dd>Can be one of the following:<br>
            CV_STORAGE_READ - the storage is open for reading<br>
            CV_STORAGE_WRITE_TEXT - the storage is open for writing data in text format<br>
            CV_STORAGE_WRITE_BINARY - the storage is open for writing data in XDR and base64-encoded
                                      binary format<br>
</dl><p>
The function <a href="#decl_cvOpenFileStorage">cvOpenFileStorage</a> open existing file storage or creates a new storage.
The file has XML format and it allows user to store as standard OpenCV arrays and dynamic structures
as well as custom data structures. The function returns pointer to <a href="#decl_CvFileStorage">CvFileStorage</a> structure,
which declaration is hidden, though not needed to access directly.</p>


<hr><h3><a name="decl_cvReleaseFileStorage">ReleaseFileStorage</a></h3>
<p class="Blurb">Releases file storage</p>
<pre>
void  cvReleaseFileStorage( CvFileStorage** storage );
</pre><p><dl>
<dt>storage<dd>Double pointer to the released file storage.
</dl><p>
The function <a href="#decl_cvReleaseFileStorage">cvReleaseFileStorage</a> closes the file on disk that has been written or read
and releases all temporary structures.
It must be called after all I/O operations with the storage are finished.</p>


<hr><h3><a name="decl_cvWrite">Write</a></h3>
<p class="Blurb">Writes array or dynamic structure to the file storage</p>
<pre>
void  cvWrite( CvFileStorage* storage, const char* name,
               const void* structPtr,
               CvAttrList attributes=cvAttrList(),
               int flags=0 );
</pre><p><dl>
<dt>storage<dd>File storage.
<dt>name<dd>Name, or ID, of the written structure. It is used to index the written information and
            then access it using these ID's. If it is NULL or empty (""), no ID is written.
            If it has special value "&lt;auto&gt;", the address of the written structure in heximal
            notation will be used as the name.
<dt>structPtr<dd>The written structure - CvMat*, IplImage*, CvSeq*, CvGraph* etc.
<dt>attributes<dd>The list of attributes that can be formed from NULL-terminated array of &lt;<em>attr_name</em>, <em>attr_value</em>&gt;
pairs using <a href="#decl_cvAttrList">cvAttrList</a>() function (see the example below). Most often it is just empty. The passed attributes
override standard attributes with the same name, e.g. user may specify <em>header_dt</em> or <em>dt</em>
attributes to write dynamic structures with custom headers and element types.
<dt>flags<dd>The operation flags passed into the specific loading/storing function for the particular data type.
             Usually it is not used and may be set to 0.
             In case of contour trees (for details see <a href="OpenCVRef_ImageProcessing.htm#decl_cvFindContours">cvFindContours</a> function in <em>Structural Analysis</em>
             chapter of the reference) it may be set to CV_WRITE_TREE to force the whole contour tree
             to be written.
</dl><p>
The function <a href="#decl_cvWrite">cvWrite</a> writes a passed structure to OpenCV file storage.
The sample below demonstrates how to write different types of data to storage.</p>
<pre>
/****************** Writing Data **************************/
#include &lt;cv.h&gt;

int main( int argc, char** argv )
{
    CvMemStorage* memstorage = cvCreateMemStorage(0);
    CvFileStorage* storage = cvOpenFileStorage( "sample.xml", 0, CV_STORAGE_WRITE_TEXT );
    CvMat* mat = cvCreateMat( 3, 3, CV_32FC1 );
    CvSeq* seq = cvCreateSeq( CV_32SC1, sizeof(CvSeq), sizeof(int), memstorage );
    char* seq_attr[] =
    {
    "created_by", argv[0],
    "the_sequence_creation_date", "1 Sep 2002",
    "comment", "just a comment",
    0
    };
    CvTermCriteria criteria = { CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, 10, 0.1 };
    const char* string1 = "test";
    int i;

    cvSetIdentity( mat );
    cvWrite( storage, "The identity matrix", mat, cvAttrList(), 0 );

    for( i = 0; i &lt; 10; i++ )
        cvSeqPush( seq, &i );

    cvWrite( storage, "SmallSequence", seq, cvAttrList(seq_attr,0), 0 );
    cvWriteElem( storage, "SampleStructure", "iid", &criteria ); /* writing C structure, see below */
    cvWriteElem( storage, "SampleString", "a", string1 ); /* writing C string, see below */

    cvReleaseFileStorage( &storage );
    cvReleaseMemStorage( &memstorage );
    return 0;
}
/**********************************************************/
</pre>
<p>After compiling and runnning the sample the file <em>sample.xml</em> will contain something like this:</p>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;opencv_storage&gt;
&lt;struct id="The identity matrix" type="CvMat" dt="f" size="3 3" format="text"&gt;
  1.000000e+000  0.000000e+000  0.000000e+000  0.000000e+000  1.000000e+000
  0.000000e+000  0.000000e+000  0.000000e+000  1.000000e+000
&lt;/struct&gt;
&lt;struct id="SmallSequence" type="CvSeq" flags="42990003" dt="i" format="text"
 created_by="D:\OpenCV\bin\test.exe" the_sequence_creation_date="1 Sep 2002"
 comment="just a comment"&gt;
      0      1      2      3      4      5      6      7      8      9
&lt;/struct&gt;
&lt;elem id="SampleStructure" dt="iid" value="      3     10  1.000000000000000e-001"/&gt;
&lt;elem id="SampleString" dt="a" value="test"/&gt;
&lt;/opencv_storage&gt;
</pre>



<hr><h3><a name="decl_cvStartWriteStruct">StartWriteStruct</a></h3>
<p class="Blurb">Writes the opening tag of a compound structure</p>
<pre>
void  cvStartWriteStruct( CvFileStorage* storage, const char* name,
                          const char* typeName=0, const void* structPtr=0,
                          CvAttrList attributes=cvAttrList());
</pre><p><dl>
<dt>storage<dd>File storage.
<dt>name<dd>Name, or ID, of the written structure. It is used to index the written information and
            then access it using these ID's. If it is NULL or empty (""), no ID is written.
            If it has special value "&lt;auto&gt;", the address of the written structure in heximal
            notation will be used as the name.
<dt>structPtr<dd>The written structure pointer. It is not used unless <em>name = "&lt;auto&gt;"</em>.
<dt>attributes<dd>The list of attributes (the same as in the previous function)
</dl><p>
The function <a href="#decl_cvStartWriteStruct">cvStartWriteStruct</a> writes the opening tag of a compound structure.
It is used by <a href="#decl_cvWrite">cvWrite</a> function and can be used explicitly to group some
structures or write an writer for some custom data structure.</p>


<hr><h3><a name="decl_cvEndWriteStruct">EndWriteStruct</a></h3>
<p class="Blurb">Closes the last opened tag</p>
<pre>
void  cvEndWriteStruct( CvFileStorage* storage );
</pre><p><dl>
<dt>storage<dd>File storage.
</dl><p>
The function <a href="#decl_cvEndWriteStruct">cvEndWriteStruct</a> closes the most recent opened tag.</p>


<hr><h3><a name="decl_cvWriteElem">WriteElem</a></h3>
<p class="Blurb">Writes a scalar variable</p>
<pre>
void  cvWriteElem( CvFileStorage* storage, const char* name,
                   const char* elem_spec, const void* data_ptr );
</pre><p><dl>
<dt>storage<dd>File storage
<dt>name<dd>Name, or ID, of the written scalar. As usual, "&lt;auto&gt;" means that the data pointer
            will be used as a name.
<dt>elem_spec<dd>A sequence of character each of whose specifies a type of particualar field of
                 the written structure:<ul>
                    <li>'a' - NULL-terminated C string. It must be the only character of specification string.
                    <li>'u' - 8-bit unsigned number
                    <li>'c' - 8-bit signed number
                    <li>'s' - 16-bit signed number
                    <li>'i' - 32-bit signed number
                    <li>'f' - single precision floating-point number
                    <li>'d' - double precision floating-point number
                    <li>'p' - pointer, it is not stored, but it takes some space in the input structure,
                              so it must be specified in order to write the subsequent fields correctly.
                    <li>'r' - the same as pointer, but the integer number, but the lowest 32 bit of
                              the pointer are written as an integer. This is useful for storing dynamic
                              structures where different nodes reference each other. In this case the
                              pointers are replaced with some indices, the structure is written and,
                              the pointers are restored back.
                    </ul>
<dt>data_ptr<dd>Pointer to the written data. The written data can be a single value of one of basic
                numerical types (<em>unsigned char, char, short, int, float</em> or <em>double</em>),
                C structure containing one or more numerical fields or a character string.
                In case of C structures an ideal alignment must be used - <em>short</em>'s must be aligned by
                2 bytes, <em>integer</em>'s and <em>float</em>'s by 4 bytes and <em>double</em>'s by 8 bytes.
                Usually such an alignment is used by C/C++ compiler by default, however some structures,
                e.g. <em>BITMAPFILEHEADER</em> Win32 structure break this rule. If you want to store
                such a structure, you may use sprintf( elem_spec, "%du", sizeof(my_struct)) to form
                an element spec that allows to store arbitrary structure, though the representation will
                neither be readable nor portable.
</dl><p>
The function <a href="#decl_cvWriteElem">cvWriteElem</a> writes a single numberical value, a structure of numerical values
or a character string. Here are some examples (see <a href="#decl_cvWrite">cvWrite</a> function discussion for complete sample):</p>
<pre>
CvScalar scalar = { 1., 2., 3.14, 4. };
cvWriteElem( filestorage, "scalar1", "4d", &scalar );

CvPoint pt = { 100, 50 };
cvWriteElem( filestorage, "feature_point", "2i", &pt };

struct
{
    char c;
    uchar u;
    short s;
    int i;
    float f;
    double d;
}
big_twos = { 20, 200, 20000, 2000000, 2e10, 2e100 };
cvWriteElem( filestorage, "big_twos", "cusifd", &big_twos );

cvWriteElem( filestorage, "string1", "a", "Hello, world!" };
</pre>


<hr><h3><a name="decl_cvRead">Read</a></h3>
<p class="Blurb">Reads array or dynamic structure from the file storage</p>
<pre>
void*  cvRead( CvFileStorage* storage, const char* name, CvAttrList** list=0 );
</pre><p><dl>
<dt>storage<dd>File storage.
<dt>name<dd>Name of the structure to read.
<dt>list<dd>Optional output parameter that is filled with the node attributes list.
</dl><p>
The function <a href="#decl_cvRead">cvRead</a> reads a structure with the specified name from OpenCV file storage.
The structure is stored inside the file storage so it is be deallocated when the file storage
is released, except the case when it is dynamic strucutre and non-NULL memory storage was
passed to <a href="#decl_cvOpenFileStorage">cvOpenFileStorage</a> function. If you want to keep the sturcture, use
<a href="#decl_cvClone*">cvClone*</a>.


<hr><h3><a name="decl_cvReadElem">ReadElem</a></h3>
<p class="Blurb">Reads a scalar variable</p>
<pre>
void  cvReadElem( CvFileStorage* storage, const char* name, void* data_ptr );
</pre><p><dl>
<dt>storage<dd>File storage
<dt>name<dd>Name of the variable to read.
<dt>data_ptr<dd>Pointer to the destination structure. In case of strings, <em>data_ptr</em> should
be <em>char**</em> - pointer to the string pointer that is filled by the function.
</dl><p>
The function <a href="#decl_cvReadElem">cvReadElem</a> reads a single numberical value, a structure of numerical values
or a character string. The order the variables are read in may be different from the order they are
written. Here are examples - counterparts for examples from <a href="#decl_cvWriteElem">cvWriteElem</a> discussion:</p>
<pre>
CvScalar scalar;
cvWriteElem( filestorage, "scalar1", &scalar );

CvPoint pt;
cvWriteElem( filestorage, "feature_point", &pt };

struct
{
    char c;
    uchar u;
    short s;
    int i;
    float f;
    double d;
}
big_twos;

cvReadElem( filestorage, "big_twos", &big_twos );

const char* string1 = 0;
cvReadElem( filestorage, "string1", (void*)&string1 };
</pre>


<hr><h3><a name="decl_CvFileNode">CvFileNode</a></h3>
<p class="Blurb">XML node representation</p>
<pre>
typedef struct CvFileNode
{
    int       flags;         /* micsellaneous flags */
    int       header_size;   /* size of node header */
    struct    node_type* h_prev; /* previous node having the same parent */
    struct    node_type* h_next; /* next node having the same parent */
    struct    node_type* v_prev; /* the parent node */
    struct    node_type* v_next; /* the first child node */
    const char* tagname; /* INTERNAL: XML tag name */
    const char* name; /* the node name */
    CvAttrList* attr; /* list of attributes */
    struct CvFileNode* hash_next; /* INTERNAL: next entry in hash table */
    unsigned hash_val; /* INTERNAL: hash value */
    int elem_size; /* size of a structure elements */
    struct CvTypeInfo* typeinfo; /* INTERNAL: type information */
    const char* body; /* INTERNAL: pointer to the structure or scalar content within XML file,
                         filled by XML parser */
    const void* content; /* the read structure, NULL if it is read yet */
}
CvFileNode;
</pre>
<p>
The structure <a href="#decl_CvFileNode">CvFileNode</a> represents an XML node - building block of OpenCV file storage.
The nodes are organized into tree that has a root node correponding to &lt;opencv_storage&gt; tag.
When a file storage is written, the tree is constructed by <a href="#decl_cvWrite">cvWrite</a>, <a href="#decl_cvStartWriteStruct">cvStartWriteStruct</a>,
<a href="#decl_cvEndWriteStruct">cvEndWriteStruct</a> and <a href="#decl_cvWriteElem">cvWriteElem</a> functions, and it does not to be accessed directly
in most of cases.
When the file storage is read, the whole tree is reconstructed by XML parser in <a href="#decl_cvOpenFileStorage">cvOpenFileStorage</a>
function, but none of nodes are decoded.
Instead, a particular node can be decoded via <a href="#decl_cvReadFileNode">cvReadFileNode</a> function, after its pointer is
retrived by the node name using <a href="#decl_cvGetFileNode">cvGetFileNode</a> function or the node is reached from the root
node. The functions <a href="#decl_cvInitTreeNodeIterator">cvInitTreeNodeIterator</a>, <a href="#decl_cvNextTreeNode">cvNextTreeNode</a> and <a href="#decl_cvPrevTreeNode">cvPrevTreeNode</a>
can be used to traverse the XML tree.
When the node is decoded, <em>content</em> field becomes valid and the same pointer will be
returned by sebsequent calls to <a href="#decl_cvReadFileNode">cvReadFileNode</a> or <a href="#decl_cvRead">cvRead</a> for this node.
</p>


<hr><h3><a name="decl_cvGetFileNode">GetFileNode</a></h3>
<p class="Blurb">Finds XML node by name</p>
<pre>
CvFileNode* cvGetFileNode( CvFileStorage* storage, const char* name );
</pre><p><dl>
<dt>storage<dd>File storage.
<dt>name<dd>The searched node name. If it is NULL, the root of the XML tree is returned.
</dl><p>
The function <a href="#decl_cvGetFileNode">cvGetFileNode</a> locates XML node by name and returns pointer to the node
or NULL if the node is not found.</p>.


<hr><h3><a name="decl_cvReadFileNode">ReadFileNode</a></h3>
<p class="Blurb">Decodes XML node content</p>
<pre>
void* cvReadFileNode( CvFileStorage* storage, CvFileNode* node, CvAttrList** list=0 );
</pre><p><dl>
<dt>storage<dd>File storage.
<dt>node<dd>The node to decode.
<dt>list<dd>Optional output parameter that is filled with the node attributes list.
</dl><p>
The function <a href="#decl_cvReadFileNode">cvReadFileNode</a> decodes the file node content.
If <em>content</em> field of the node is not NULL, no decoding is done and the pointer is simply returned.</p>.


</body>
</html>

